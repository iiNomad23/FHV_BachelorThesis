% !TeX document-id = {f5eab2f7-1326-43b3-ac0e-350c2acbded8}

% !TeX TXS-program:compile = txs:///pdflatex/[--shell-escape]

\documentclass[a4paper, fontsize=11pt, parskip=half, twoside]{scrreprt}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}   
\usepackage{graphicx}       
\usepackage[english, ngerman]{babel}
\usepackage{csquotes} % for displaying quotes  
\usepackage{acronym}
\usepackage{eurosym}
\usepackage[linktocpage=true]{hyperref}
\usepackage{xurl}
\usepackage[bindingoffset=8mm]{geometry}
\usepackage{caption}
\captionsetup{format=hang, justification=raggedright}
\usepackage[style=authoryear, backend=biber]{biblatex}
\usepackage{float}
\usepackage{rotating}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{outlines} % for nested lists
\usepackage{tikz} % for drawing
\usepackage{microtype} % improve micro typography for better distribution
\usepackage{minted} % for source code
\usepackage{caption} % caption for e.g. figures
\usepackage{subcaption} % captions for multiple figures
\usepackage{datetime} % for custom dates
\usepackage[german]{cleveref} % clever refs - set labels as always (\label{fig:hello}), \cref{fig:hello}
\usepackage[onehalfspacing]{setspace} % 1.5x line space

% adds generic commands for degree, ohm, ..
\usepackage{textcomp}
\usepackage{gensymb}

\usepackage{todonotes}

% custom commands
\renewcommand{\listingscaption}{Quellcode}
\renewcommand{\listoflistingscaption}{Quellcodeverzeichnis}
\providecommand*{\listingautorefname}{Quellcode}

\definecolor{bg}{rgb}{0.93, 0.93, 0.93}
\setminted{
	autogobble, 
	tabsize=4, 
	numbers=left,
	numbersep=15pt,
	bgcolor=bg,
	fontsize=\footnotesize
}
\renewcommand{\fcolorbox}[4][]{#4} % "disables" syntax errores in minted code blocks 

% define date variable for whole doc
% use \displaydate{date} where needed to insert this date

\newdate{date}{20}{05}{2023}
\date{\displaydate{date}}

% add zotero file for citations
\addbibresource{reference.bib}

\begin{document}
	
	\thispagestyle{empty}
	
	\cleardoublepage   % force output to a right page
	\thispagestyle{empty}
	\begin{titlepage}
		\begin{flushright}
			\includegraphics[width=0.4\linewidth]{assets/Logo-A3.jpg}
		\end{flushright}
		
		\begin{flushleft}
			\section*{Entwicklung eines Test Case Management Systems für Gantner Instruments Messsysteme}
			%\subsection*{\papersubtitle}
			\vspace{1cm}
			
			\vspace{0.5cm}
			Bachelorarbeit\newline
			zum Erlangen des akademischen Grades\newline
			
			\vspace{0.5cm}
			\textbf{Bachelor of Science in Engineering (BSc)}
			
			\vspace{1cm}
			Fachhochschule Vorarlberg\newline
			Informatik - Software and Information Engineering\newline
			
			\vspace{0.5cm}
			Betreut von\newline
			Dipl.-Ing. Dr. techn. Ralph Hoch
			
			\vspace{0.5cm} 
			Vorgelegt von\newline
			Marco Prescher	
			
			\vspace{0.5cm}
			Dornbirn, am \displaydate{date}
		\end{flushleft}
	\end{titlepage}
	
	% Kurzreferat
	\newpage
	\section*{Kurzreferat}
	\subsection*{Entwicklung eines Test Case Management Systems für Gantner Instruments Messsysteme}
	
	Die Entwicklung technischer Systeme ist ein komplexer und kostspieliger Prozess. 
	Daher ist es wichtig, dass die Produkte vor der Auslieferung an den Kunden gezielt und sorgfältig getestet werden. 
	Dies wird durch Zeitdruck und Deadlines oftmals vernachlässigt, oder nur unzureichend durchgeführt. 
	
	Durch ein Test Case Management System ist es möglich, dass Features vor dem Release der Produkte abgenommen und getestet werden müssen. 
	Das wiederum ermöglicht, dass neu implementierte Features gründlich getestet werden und somit zu einer hohen Qualität beitragen.
	Dadurch kann stabile Hardware sowie effiziente und gut strukturierte Software ohne große Verzögerung an den Kunden ausgeliefert werden.
	
	Ziel dieser Arbeit ist es, ein Test Case Management System zu entwickeln, mit dem es möglich ist Features von bestimmten Geräten und Systemen zu beschreiben.
	Zusätzlich soll das Test Case Management System in der Lage seine Testergebnisse von einem bereits bestehenden Test Automation System zu empfangen und diese zu den beschriebenen Features zuzuordnen.
	
	Dies kann erreicht werden, indem gut strukturierte APIs sowie präzise Feature-Beschreibungen und Testergebnisse bereitgestellt sind und diese in einer Datenbank eingepflegt werden. 
	Durch sorgfältige Dokumentation von Features und Testergebnisse können Statistiken und Reports erstellt werden, die wiedergeben, welche Features erfolgreich getestet wurden.
	Aufgrund dessen ist eine Überwachung des Testfortschritts möglich und es kann festgestellt werden welche Features Release-fähig und mit gutem Gewissen verkauft werden können.
	
	\newpage
	\section*{Abstract}
	\subsection*{Development of a Test Case Management System for Gantner Instruments Measurement Systems}
	
	The development of technical systems is a complex and costly process. 
	Therefore, it is important that products are thoroughly tested before delivery to the customer. 
	However, this is often neglected or done insufficiently due to time pressure and deadlines. 
	A well-structured test plan can minimize this risk and integrate the testing process into the product development cycle. 
	This allows stable hardware and efficient, well-structured software to be delivered to the customer without significant delays.
	
	Using techniques such as feature-oriented development, certain features must be accepted and tested before the product release. 
	This in turn allows newly implemented features to be thoroughly tested and contribute to high quality. 
	
	This can be achieved by structuring features in a database. 
	A system based on these feature descriptions can support automatic testing, conduct targeted tests for individual features, and accelerate their acceptance. 
	This reduces testing effort and provides focused feedback to the developers.
	
	% Inhaltsverzeichnis
	\cleardoublepage   % force output to a right page
	\setcounter{tocdepth}{2}
	\setcounter{secnumdepth}{4}
	\tableofcontents
	
	% Abbildungsverzeichnis
	\clearpage
	\phantomsection
	\addcontentsline{toc}{chapter}{Abbildungsverzeichnis}
	\listoffigures
	
	% Quellcodeverzeichnis
	\clearpage
	\phantomsection
	\addcontentsline{toc}{chapter}{Quellcodeverzeichnis}
	\listoflistings
	
	% Abkürzungsverzeichnis
	\clearpage
	\phantomsection
	\addcontentsline{toc}{chapter}{Abkürzungsverzeichnis}
	\chapter*{Abkürzungsverzeichnis}
	\begin{acronym}
		\acro{API}{Application Programming Interface}
		\acro{JSON}{JavaScript Object Notation}
		\acro{TCMS}{Test Case Management System}
		\acro{TDD}{Test Driven Development}
		\acro{EF}{Entity Framework}
		\acro{ORM}{Object Relational Mapping}
		\acro{OAS}{OpenAPI Spezifikation}
		\acro{HTTP}{Hypertext Transfer Protocol}
		\acro{MVP}{Minimum Viable Product}
		\acro{UI}{User Interface}
		\acro{DDD}{Domain Driven Design}
		\acro{DHCP}{Dynamic Host Configuration Protocol}
		\acro{GI}{Gantner Instruments}
		\acro{TAS}{Test Automation System}
		\acro{IDE}{Integrated Development Environment}
		\acro{ID}{Identifier}
		\acro{SQL}{Structured Query Language}
		\acro{DTO}{Data Transfer Object}
		\acro{DI}{Dependency Injection}
	
		\acrodefplural{TCMS}{Test Case Management Systeme}
	\end{acronym}
	
	\clearpage
	\section*{Danksagung}
	Ich möchte mich aufrichtig bei Ralph Hoch, der Firma Gantner Instruments und allen Mitarbeitenden bedanken, die mir bei der Vollendung dieser Arbeit geholfen haben. 
	Ihre Unterstützung und Expertise waren von unschätzbarem Wert und haben zum erfolgreichen Abschluss dieses Projekts beigetragen. 
	Vielen Dank für Ihre harte Arbeit und Ihr Engagement. 
	Ich schätze Ihre Zusammenarbeit sehr.
	
	
	
	\clearpage
	\chapter{Einleitung}
	
	\begin{flushright}
		\rightskip=8cm\textit{``Time is money.''} \\
		\vspace{.2em}
		\rightskip=6cm--- \textcite{franklin_advice_1748}
	\end{flushright}

	In der Softwareentwicklung kann es durch Fehler und Mängel zu Verzögerungen und dadurch zu Verlusten kommen.
	Deswegen wurde in Zusammenarbeit mit der Firma \acfi{GI} geplant ein \acfi{TCMS} zu entwickeln.
	Diese Arbeit fokussiert sich daher auf die Implementierung von einem \ac{TCMS} und vergleicht verschiedene vorhandene Lösungen.
	
	
	\section{Motivation} \label{sec:motivation}
	Die Entwicklung technischer Systeme ist ein komplexer Prozess, der eine hohe Qualität erfordert, um den Anforderungen der Kunden gerecht zu werden. 
	Damit diese Qualität auch gewährleistet wird, müssen Fehler sowie Mängel identifiziert und ausgebessert werden. 
	Ein \ac{TCMS} bietet eine Lösung, um diesen Prozess zu vereinfachen und effektiver zu gestalten. 
	Durch die Verwendung eines \ac{TCMS} können Angestellte aus verschiedenen Abteilungen, wie z.B. der Software-, Hardware-, Support- oder Marketingabteilung, die Qualität des Produkts gemeinsam verbessern. 
	
	\section{Problemstellung}
	Durch die von \autoref{sec:motivation} angesprochene Komplexität technischer Systeme ist bekannt, dass Fehler, die erst spät im Entwicklungsprozess entdeckt werden, viel kostspieliger zu beheben sind als Fehler, die frühzeitig identifiziert und behoben werden. (\textcite{westland_cost_2002})
	
	Infolgedessen suchen Unternehmen nach Lösungen, um den Testprozess effektiver zu gestalten und Fehler früher im Entwicklungszyklus zu identifizieren. 
	\ac{TCMS} bietet eine solche Lösung, indem es Entwicklern und Testern ermöglicht, Testfälle effizient zu planen und zu verwalten sowie Testergebnisse zu erfassen, darzustellen und somit auch zu verfolgen. 
	Obwohl \ac{TCMS} in der Industrie weit verbreitet sind und es einige fertige Lösungen gibt, gibt es jedoch nicht immer die perfekte Lösung um ein bestehendes \ac{TCMS} für das eigene Projekt anzuwenden. 
	Insbesondere gibt es Bedenken hinsichtlich der Anwendbarkeit und Integration von einem schon bestehendem \ac{TCMS}, da dieses System auch mit internen Tools kommunizieren können muss.
	Diese Probleme stellen Hindernisse dar, die die Einführung von \ac{TCMS} in einem Unternehmen erschweren. 
	Diese Arbeit beschäftigt sich mit diesen Problemen und untersucht, wie ein \ac{TCMS} effektiv eingesetzt werden kann.
	
	\section{Zielsetzung}
	Das Ziel dieser Arbeit ist es, die Verwendung von \ac{TCMS} zu untersuchen und zu bewerten. 
	Zudem ein auf unser eigenes Produkt angepasstes \ac{TCMS} zu entwickeln. 
	Hiermit ergeben sich drei relevante fragen:
	
	\begin{itemize}
		\item Wie kann man Features, Testfälle und Testimplementierungen beschreiben? 
		\item Wie in Datenbank schreiben und lesen? 
		\item Wie mit Testläufen verknüpfen?
	\end{itemize}
	
	Insbesondere möchten wir die folgenden Ziele erreichen:
	
	\begin{itemize}
		\item Die Vor- und Nachteile der Verwendung von einem \ac{TCMS} zu identifizieren und zu analysieren.
		\item Empfehlungen für die erfolgreiche Implementierung eines \ac{TCMS} in der Softwareentwicklung zu geben, einschließlich der Identifizierung bewährter Praktiken.
	\end{itemize}
	
	Durch die Erfüllung dieser Ziele wird diese Arbeit dazu beitragen, das Verständnis für die Verwendung von einem \ac{TCMS} in der Produktentwicklung zu verbessern und Unternehmen dabei zu unterstützen, den Testprozess zu optimieren und die Qualität ihrer Produkte zu verbessern.
	
	
	
	\chapter{Stand der Technik}
	Dieses Kapitel gibt einen Überblick über den aktuellen Stand der Technik von Testarten, \ac{TCMS} sowie deren Verwendung und Integration mit bestehenden Systemen. 
	Weiters werden Technologien, auf denen das in dieser Arbeit entwickelte \ac{TCMS} aufbaut, beschrieben.
	
	\section{Testarten} \label{sec:testtypes}
	Während der Entwicklung eines Produkts kommen unterschiedliche Testarten zum Einsatz. 
	\textcite{atlassian_unterschiedlichen_nodate} beschreibt sieben unterschiedliche Testverfahren die je nachdem andere Aspekte eines Produkts testen.
	In \textcite{noauthor_software_nodate} wird beschreiben, dass dabei zwischen \emph{Funktionalen} und \emph{Nicht-Funktionalen} Tests unterschieden werden.
	Zu der funktionalen Testfamilie zählen beispielsweise Unit-Tests und Integrationstests.
	Nicht funktionale Testarten sind beispielsweise Leistung, Last und Stresstests sowie Usability-Tests zu den nicht funktionalen Testfamilie gehören.
	
	Ein paar der am häufigsten vorkommenden Testarten sind:
	
	\begin{itemize}
		\item Unit-Tests
		\item Integrationstests
		\item Funktionstests
		\item Leistungstests
	\end{itemize}

	Um eine Testabdeckung sicherzustellen und den allgemeinen Testprozess zu optimieren werden \ac{TCMS} eingesetzt. 
	Diese Systeme bieten eine zentrale Plattform zur Verwaltung von Testfällen, wo Tests, die für ein Release oder Produkt erforderlich sind, erstellt und dokumentiert werden können (Siehe \autoref{sec:tcms}). (\textcite{ammann_introduction_2016})
	
	\subsection{Unit-Tests}
	Im Allgemeinen sind Unit-Tests Tests die beispielsweise Methoden einer Klasse mit unterschiedlichen Parametern testet. 
	Sie sind automatisierbar und können von einer Continuos-Integration-Pipeline durchgeführt werden. 
	Diese Tests ermöglichen eine kontinuierliche Überprüfung der Funktionsfähigkeit des Produkts im Entwicklungsprozess und unterstützen das frühzeitige Finden von Fehlern.
	
	\subsection{Integrationstests}
	Integrationstests sind Tests, die sicherzustellen, dass verschiedene Module oder Services, problemlos miteinander interagieren können. 
	Durch diese Tests kann die Funktionalität einzelner Teile der Anwendung überprüft werden, wie beispielsweise die Interaktion mit einer Datenbank oder der Zusammenarbeit von Microservices.
	
	\subsection{Funktionstests}
	Funktionstests werden integriert, um ausschließlich Ergebnisse einer gegebenen Funktion zu überprüfen. Dabei werden Spezifikation vor der Testausführung festgelegt und diese dann mit den Ergebnissen verglichen.
	
	Während Integrationstests beispielsweise nur prüfen, ob Datenbankabfragen generell möglich sind, wird bei einem Funktionstest ein bestimmter Wert aus der Datenbank abgerufen und dieser mit den angegebenen Spezifikationen geprüft.
	
	\subsection{Leistungstests}
	Leistungstests prüfen das Verhalten eines Systems unter verschiedenen Lastprofilen zu überprüfen. 
	Häufig wird Zuverlässigkeit, Geschwindigkeit, Skalierbarkeit und Reaktionsfähigkeit einer Anwendung getestet. 
	Außerdem können Leistungstests mögliche Engpässe in einer Anwendung identifizieren.
	
	
	\section{Black-Box und White-Box Testing}
	Sowohl \emph{Black-Box} als auch \emph{White-Box} Tests werden in der Software Entwicklung häufig verwendet, um Fehler als auch die Qualität des Produkts zu evaluieren. 
	Dabei gibt es zwischen den beiden wichtige Unterschiede. (Siehe: \autoref{fig:WhiteBoxBlackBoxTesting})
	
	Bei White-Box Testing handelt es sich um Unit-Tests die den Code, die Struktur und das Desgin des zu testeten Produkts überprüfen. 
	Wobei der Inhalt des Codes für den Tester einsehbar ist.
	White-Box Testing bezieht sich dabei nur auf die interne Funktion der Software.
	
	Bei Black-Box Testing wird die interne Struktur, das Design und die Implementierung nicht berücksichtigt.
	Hier werden nur die Ausgaben oder Reaktionen von dem System geprüft.
	Black-Box Testing bezieht sich hiermit nur auf die externe Funktion der Software. (\textcite[Seite 12]{nidhra_black_2012})
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.6]{assets/WhiteBoxBlackBoxTesting.jpg}
		\caption{Black-Box/White-Box Testing (Quelle: \textcite{khandelwal_difference_2019})}
		\label{fig:WhiteBoxBlackBoxTesting}
	\end{figure}
	
	
	\section{Test Driven Devlopment}
	\acfi{TDD} ist ein Konzept, bei dem Tests zuerst geschrieben werden und erst anschließend eine passende Implementierung erstellt wird die genau soviel beinhaltet, dass der Test erfolgreich durchgeführt werden kann.
	\autoref{fig:tdd-cycle} zeigt einen \ac{TDD} Zyklus.
	\ac{TDD} bietet daher mehrere Vorteile (\textcite{ammann_introduction_2016}):
	
	\begin{itemize}
		\item Geschriebener Code kann überarbeitet oder verschoben werden, ohne dass die Gefahr besteht, Funktionalität zu beschädigen.
		\item Die Tests selbst werden durch die Implementierung getestet.
		\item Die Anforderungen können mit geringerem Aufwand umgesetzt werden, da nur die benötigte Funktion geschrieben wird.
	\end{itemize}
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.25]{assets/tdd-cycle.png}
		\caption{\acl{TDD} cycle (Quelle: \textcite{noauthor_test-driven_nodate})}
		\label{fig:tdd-cycle}
	\end{figure}
	
	\section{Test Case Management System} \label{sec:tcms}
	Ein \acl{TCMS} (\ac{TCMS}) ist eine Software, mit dem Test-Teams für ein bestimmtes Projekt oder eine Anwendung Testfälle verwalten, organisieren und analysieren können.
	Es hilft bei der Planung, Überwachung und Dokumentation von Tests und ermöglicht es, Testfälle sicher und effizient zu verwalten.
	
	Ein \ac{TCMS} ist ein wichtiges Werkzeug, um einen strukturierten und effektiven Testprozess zu gewährleisten und den Qualitätsstandard einer Anwendung zu verbessern.
	Es verfügt über Basisfunktionen wie Testfall-Erstellung, Testfall-Verwaltung, Testfall-Ausführung und Ergebnisberichterstattung. 
	Weiters kann ein solches System auch eine integrierte Umgebung für die Zusammenarbeit von verschiedene Abteilungen in einer Firma bereitstellen.
	
	Zusätzlich zu den Basisfunktionen sind weitere wichtige Merkmale (\textcite{lead_articles_nodate}):
	
	\begin{itemize}
		\item Attraktive Benutzeroberfläche und benutzerfreundliches Design
		\item Nachvollziehbarkeit
		\item verbesserte Zeitplanung und Organisation für Releases durch Reports
		\item Überwachung und Metriken
		\item Flexibilität
	\end{itemize}
	
	
	\subsection{Allgemeine Vorteile von Test Case Management Systemen}
	Einer der Hauptvorteile eines \ac{TCMS} besteht darin, dass sie den Testprozess verbessern. 
	Sie unterstützen auch die Kontrolle der Gesamtkosten, indem sie die Testautomatisierung nutzen, um einen reibungslosen Ablauf zu gewährleisten.  
	
	Einige Vorteile von \ac{TCMS} bezüglich der Testausführungsläufe sind (\textcite{lead_articles_nodate}):
	
	\begin{itemize}
		\item Sie geben einen besseren Überblick über das zu testende System, halten den gesamten Prozess auf Kurs und koordinieren die Testaktivitäten.
		\item Sie helfen bei der Feinabstimmung des Testprozesses, indem sie die Zusammenarbeit, Kommunikation und Auswertung unterstützen.
		\item Sie dokumentieren Aufgaben, Fehler und Testergebnisse und vereinfachen den Prozess, indem sie alles in einer einzigen Anwendung erledigen.
		\item Sie sind skalierbar und können eingesetzt werden, wenn die Testaktivitäten umfangreicher und komplexer werden.
	\end{itemize}
	
	
	\subsection{Überblick von bestehenden Test Case Management Systeme}
	Auf dem Markt gibt es eine Vielzahl fertiger und direkt verwendbaren \ac{TCMS}, die die Verwaltung von Tests vereinfacht.
	
	Einige bekannte \ac{TCMS} sind, siehe \autoref{fig:tcms_logo}:
	
	\begin{itemize}
		\item \textcite{noauthor_testrail_2023} 
		
		Webbasiertes \ac{TCMS}, ist zentralisiert und hat folgende Features:
		
		\begin{itemize}
			\setlength\itemsep{-0.5em}
			\item Test Planung, Verwaltung und Ausführung 
			\item Echtzeit Berichterstattung und Analysen
			\item Rückverfolgbarkeits- und Abdeckungsberichte für Anforderungen, Tests und Fehler
		\end{itemize}
		
		\item \textcite{noauthor_practitest_nodate} 
		
		Webbasiertes \ac{TCMS} und hat folgende Features:
		
		\begin{itemize}
			\setlength\itemsep{-0.5em}
			\item Test Planung, Verwaltung und Ausführung 
			\item Echtzeit Test Status Update
			\item Berichterstattung
			\item Dashboards
			\item Integrationsmöglichkeit mit Automation Tools
		\end{itemize}
		
		\item \textcite{noauthor_zephyr_nodate} 
		
		Webbasiertes \ac{TCMS}, kann in JIRA integriert werden und hat folgende Features:
		
		\begin{itemize}
			\setlength\itemsep{-0.5em}
			\item Test Planung, Verwaltung und Ausführung 
			\item Test Automatisierung
			\item Echtzeit Visualisierung von Projektstatus
		\end{itemize}
		
		\item \textcite{noauthor_tricentis_nodate} 
		
		Webbasiertes \ac{TCMS} und hat folgende Features:
		
		\begin{itemize}
			\setlength\itemsep{-0.5em}
			\item Test Planung, Verwaltung und Ausführung 
			\item Migrationsmöglichkeit von alten Test Management Lösungen
			\item Integrationsmöglichkeit mit Jenkins, Azure Pipelines, Bamboo oder jedem anderen CI/CD-Tool
			\item Anpassbare Dashboards, um über alle Releases, Projekte oder Programme im gesamten Unternehmen zu berichten
			\item Berichte per E-Mail oder URL teilen
		\end{itemize}
	\end{itemize}
	
	Welches Tool am besten geeignet ist, hängt natürlich von der jeweiligen Anwendung ab.
	\newline
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.5]{assets/best-tool-logos.jpg}
		\caption{Liste von aktuell führenden Test Case Management Systemen/Tools (Quelle: \textcite{noauthor_7_nodate})}
		\label{fig:tcms_logo}
	\end{figure}
	 
	
	\section{Verwendete Technologien} \label{sec:technologies}
	Dieser Abschnitt gibt eine Übersicht über die verwendeten Technologien, die für die Implementierung des in dieser Arbeit entwickelten \ac{TCMS} eingesetzt worden sind.
	
	\subsection{MariaDB}
	MariaDB ist eine weit verbreitete relationalen Open-Source-Datenbanken. 
	Sie wurde auf einem Fork von MySQL basierend von den ursprünglichen Entwicklern von MySQL entwickelt. 
	Der Fokus von MariaDB liegt auf Leistung, Stabilität und Offenheit. 
	Zu den jüngsten Erweiterungen gehören Clustering mit Galera Cluster 4, Kompatibilitätsfunktionen mit der Oracle-Datenbank und temporäre Datentabellen, mit denen Daten zu jedem beliebigen Zeitpunkt in der Vergangenheit abgefragt werden können. (\textcite{noauthor_mariadb_nodate})
	
	\subsection{Docker}
	Docker ist eine Plattform mit der Entwickler einfach und schnell Container erstellen, bereitstellen, ausführen, aktualisieren und verwalten können.
	\autoref{fig:docker-funktionsweise} zeigt die Funktionsweise von Docker.
	Container sind eigenständige, ausführbare Einheiten die unabhängig vom OS deployed werden können.
	Container vereinfachen die Entwicklung und Bereitstellung von verteilten Anwendungen. 
	Entwickler können Container auch ohne Docker erstellen doch Docker macht die Containerisierung schneller, einfacher und sicherer. 
	Telepresence ist die neuste Erweiterung und bietet einen einfachen Weg mit Kubernetes zu entwickeln. (\textcite{ghosh_docker_2020})
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.4]{assets/docker-funktionsweise.png}
		\caption{Funktionsweise von Docker (Quelle: \textcite{bollhoff_kubernetes_2022})}
		\label{fig:docker-funktionsweise}
	\end{figure}
	
	\subsection{Microsoft .NET Core} \label{subsec:msNetCore}
	Microsoft .NET Core ist ein Open-Source und plattformübergreifendes Framework um Applikationen auf Android, Apple, Linux und Windows Betriebssystemen zu entwickeln.
	Microsoft .NET Core unterstützt mehrere Programmiersprachen wie C\#, F\# und Visual Basic.
	Zudem bietet .NET einen Paketmanager um einfach und effizient Bibliotheken von Drittanbietern zu verwenden.
	Die neue Version .NET 8 bietet einige Neuerungen wie beispielsweise Performance-focused Typen, die die Leistung einer Anwendung erheblich verbessern soll.
	.NET 8 wird offiziell im November 2023 veröffentlicht. (\textcite{billwagner_net_nodate})

	\subsection{Microsoft ASP.NET Core}
	Microsoft ASP.NET Core ist im Gegensatz zu .NET Core ein Framework um Webanwendungen zu entwickeln. 
	ASP.NET verfügt über Vorteile wie beispielsweise Blazor mit dem man einfach und effizient eine Interaktive Webbenutzeroberfläche mit C\# entwickeln kann.
	Dieses Framework unterstützt die Entwicklung und Implementierung von \acfi{API} und Mikroservices.
	Zudem ist ASP.NET laut \textcite{noauthor_techempower_nodate} schneller als jedes andere beliebte Web-Framework. (\textcite{billwagner_net_nodate})
	
	\subsection{Entity Framework Core}
	\acfi{EF} Core ist eine \acfi{ORM} Technik für Microsofts .NET Core Technologie (\autoref{subsec:msNetCore}). 
	Die Technologie ist Open-Source, erweiterbar und plattformübergreifend.
	\ac{EF} Core unterstützt LINQ-Abfragen, Änderungsverfolgung, Aktualisierung sowie Schemamigration.
	Weiteres unterstützt \ac{EF} Core mehrere Datenbanken wie beispielsweise MySQL, PostgreSQL, Azure CosmosDB etc. und auch MariaDB.
	Die aktuelle Version von \ac{EF} Core ist 7.0 und verfügt über neue Funktionen wie z.B. das Mapping und Abfragen auf \acfi{JSON} Spalten. 
	Dabei ist es möglich einzelne Parameter von einem \ac{JSON} Objekt abzufragen und zu ändern. 
	\autoref{lst:exampleOfJsonColumn} zeigt wie das erfolgt. (\textcite{billwagner_net_nodate})
	
	\begin{listing}[ht]
		\begin{minted}{csharp}
			var jeremy = await context
			.Authors
			.SingleAsync(author => author.Name.StartsWith("Jeremy"));
			
			jeremy.Contact = new() { 
				Address = new("2 Riverside", "Trimbridge", "TB1 5ZS", "UK"), 
				Phone = "01632 88346" 
			};
		
			await context.SaveChangesAsync();
		\end{minted}
		\caption{Update von einem Parameter einer \ac{JSON} Spalte}
		\label{lst:exampleOfJsonColumn}
	\end{listing}
	
	\subsection{OpenAPI}
	Die OpenAPI-Initiative hat die \acfi{OAS} entwickelt, die eine \ac{API} Beschreibung standardisiert.
	Die \ac{OAS} ist eine Sprache für \acfi{HTTP} \ac{API}s, durch diese \ac{API}s standardisiert beschrieben werden können. 
	Mithilfe von einem OpenAPI-Code-Generator (\textcite{noauthor_openapi_nodate-1}) kann direkt Client-Code für verschiedene Technologien wie z.B. Typescript generiert werden. (\textcite{noauthor_openapi_nodate})
	
	
	
	\chapter{Anforderungen} \label{chapter:requiremnts}
	Der Hauptteil dieser Arbeit ist es ein funktionierendes \ac{TCMS} mit den genannten Technologien zu entwickeln.
	Dabei steht Zuverlässigkeit, Geschwindigkeit und Skalierbarkeit im Vordergrund.
	Zudem soll darauf geachtet werden, dass Ressourcen bzw. Entitäten, wie beispielsweise Testfälle, für mehrere Testpläne verwendet werden können, um damit mehrfache Einträge in der Datenbank zu verhindern.
	
	Das zu entwickelnde \ac{TCMS} hat folgende Anforderungen (Requirements):
	
	\begin{itemize}
		\setlength\itemsep{-0.5em}
		\item RE 1 - Produkt und Testsysteme beschreiben und darstellen
		\item RE 2 - Features beschreiben und darstellen
		\item RE 3 - Features zu einem Produkt zuordnen
		\item RE 4 - Testfälle beschreiben und darstellen
		\item RE 5 - Testfälle zu einem Feature zuordnen
		\item RE 6 - Testimplementierungen beschreiben und darstellen
		\item RE 7 - Testimplementierungen zu Testfällen und Testsysteme zuordnen
		\item RE 8 - Testläufe von Testimplementierungen zu einem Testsystem zuordnen
		\item RE 9 - Resultate von bestimmten Testläufen abzufragen
	\end{itemize}
	
	
	\section{Minimum Viable Product}
	Bei einem \acfi{MVP} handelt es sich um ein minimal brauchbares Produkt. 
	Dabei handelt es sich um die erste funktionierte Iteration eines Produkts das nur Kernfunktionalitäten beinhaltet.
	In unserem Fall ist das ein funktionierendes \ac{TCMS}, welches die oben angeführten Anforderungen abdeckt und von der Datenbankabfrage bis zur \ac{API} unterstützt.
	
	Der Vorteil ist, dass das Produkt so schnell wie möglich zum Kunden gelangt und Entwickler:innen Kundenfeedback bekommen.
	Die Kunden von dem zu entwickelnden \ac{TCMS} sind in diesem Fall die Mitarbeitenden der Firma \acl{GI}. (\textcite{alliance_what_2017})
	
	
	\section{Testen der Funktionalitäten}
	Damit der Kunde die Funktionalitäten des \ac{TCMS} auch \acfi{UI} unterstützt testen kann, wird ein webbasiertes \ac{UI} von Swagger zur Verfügung gestellt (Siehe: \autoref{fig:swaggeruiExample}).
	
	Swagger ist ein Werkzeug mit denen \ac{API}-Beschreibungen erstellt werden können.
	Zudem kann Swagger mithilfe des standardisiertem \ac{OAS} automatisch ein \ac{UI} generieren. (\textcite{noauthor_api_nodate})
	\newline
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.6]{assets/swaggerui.png}
		\caption{Beispiel \ac{UI} von Swagger (Quelle: \textcite{noauthor_host_nodate})}
		\label{fig:swaggeruiExample}
	\end{figure}

	\section{Vorgehensweise} \label{sec:userStoriesDefinition}
	Die ermittelten Anforderungen wurden in User-Stories aufgeteilt. 
	Nachfolgend sind vier User-Stories aufgeführt, die aufzeigen, welche Funktionalitäten das \ac{TCMS} beinhaltet, um die oben gelisteten Anforderungen abzudecken.
	
	\subsection{Projekt und Datenbank Aufsetzen}
	Diese User-Story beinhaltet noch keine Implementierung von Funktionalitäten, sondern beschäftigt sich mit dem Aufsetzten des Projektes und der Datenbank.
	
	Die Akzeptanzkriterien sind wie folgend:
	\begin{itemize}
		\item Projekt Struktur in die Architekturschichten aufteilen 
		\item Datenbank mit Docker aufsetzen
		\item \acfi{SQL} Statements möglich
	\end{itemize}

	Diese User-Story erfüllt noch keine Anforderungen.
	
	\subsection{Erstellen und suchen von Test-Environments}
	Als Nutzer:in möchte ich Test-Environments erstellen und suchen, sodass ich Testpläne zuordnen kann.
	
	Die Akzeptanzkriterien sind wie folgend:
	\begin{itemize}
		\item Erstellen von Test-Environments über Swagger \ac{UI}
		\item Suchen von Test-Environments über Swagger \ac{UI}
		\item Zuordnungsmöglichkeit von Testplänen über Swagger \ac{UI}
	\end{itemize}

	Diese User-Story erfüllt die Anforderungen RE 1 und RE 3.

	\subsection{Erstellen und suchen von Testplänen, Testfällen und Testimplementationen}
	Als Nutzer:in möchte ich Testpläne, Testfälle und Testimplementationen erstellen und suchen, sodass ich diese entsprechend zuordnen kann.
	
	Die Akzeptanzkriterien sind wie folgend:
	\begin{itemize}
		\item Erstellen von Testplänen, Testfällen und Testimplementationen über Swagger \ac{UI}
		\item Suchen von Testplänen, Testfällen und Testimplementationen über Swagger \ac{UI}
		\item Zuordnungsmöglichkeit von Testfällen und Testimplementationen über Swagger \ac{UI}
	\end{itemize}

	Diese User-Story erfüllt die Anforderungen RE 2, 4, 5, 6 und RE 7.
	
	\subsection{Erstellen und suchen von Testläufe}
	Als Nutzer:in möchte ich Testläufe erstellen und suchen, sodass ich Reports generieren kann.
	
	Die Akzeptanzkriterien sind wie folgend:
	\begin{itemize}
		\item Erstellen von Testläufen über Swagger \ac{UI}
		\item Suchen von Testläufen über Swagger \ac{UI}
		\item Zuordnungsmöglichkeit von Testläufen über Swagger \ac{UI}
	\end{itemize}
	
	Diese User-Story erfüllt die Anforderungen RE 8 und RE 9.
	
	\chapter{Konzept}
	Im vorherigen Kapitel wurden die Anforderungen des zu entwickelnden \ac{TCMS} festgelegt.
	Dieses Kapitel gibt einen Überblick über die konzipierte Architektur und gibt Einblick in die Planung des \ac{TCMS}.
	
	\section{Architektur}
	Grundlegend repräsentiert eine Softwarearchitektur die Organisation und den Aufbau eines Systems was die Architektur zu einer der wichtigsten Bestandteile in der Softwareentwicklung macht.
	Die Wahl der Softwarearchitektur eines Softwareprojektes hat demnach hohen Einfluss auf den späteren verlauf des Projektes was dadurch sehr kostenintensiv werden kann diese umzustellen.
	Eine gut strukturierte Softwarearchitektur bringt dementsprechend einige Vorteile (\textcite{richards_fundamentals_2020}):
	
	\begin{itemize}
		%\setlength\itemsep{-0.5em}
		\item Übersichtlichkeit
		\item bessere Wartbarkeit
		\item Erweiterbarkeit
		\item Anpassungsfähigkeit
		\item Skalierbar
		\item reduziert Kosten und verhindert Code-Duplikation
		\item erhöht die Qualität der Software
		\item hilft bei komplexen Problemstellungen
		\item reduziert den Time-to-Market Faktor durch effizienteres entwickeln
	\end{itemize}
	
	\subsection{Backend} \label{subsec:backend}
	In dieser Arbeit haben wir uns für eine Schichtenarchitektur mit \acfi{DDD} entschieden, da sich diese schon öfters bewährt hat und es gute Erfahrungen damit gab.
	\todo{MInor improvments}
	Der Aufbau dieser Architektur unterteilt sich in vier Schichten, siehe \autoref{fig:layeredArchitecture}:
	
	\begin{itemize}
		%\setlength\itemsep{-0.5em}
		\item Präsentationsschicht
		
		Diese repräsentiert \ac{API}s, die Anfragen entgegennimmt und dementsprechend Antworten liefert.
		Die Anfragen werden an die Applikationsschicht weitergeleitet.
		
		\item Applikationsschicht
		
		Diese Schicht interagiert mit der Präsentationsschicht und der Infrakstrukturschicht.
		Abhängig von den aus der Präsentationsschicht weitergeleiteten Anfragen werden Domain-Objects erzeugt und an die Infrakstrukturschicht weitergeleitet.
		
		\item Domainschicht
		
		Beinhaltet die Entitäten von der Domain und ist das Zentrum der Architektur.
		Diese Schicht wird von der Applikationsschicht und von der Infrastrukturschicht aufgerufen und beinhaltet die ganze Business-Logik.
		
		\item Infrastrukturschicht
		
		Hier wird mit der Applikationsschicht, der Domainschicht und der Datenbank interagiert.
	\end{itemize}

	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.5]{assets/layeredArchitecture.png}
		\caption{Übersicht einer Schichtenarchitektur (Quelle: \textcite{zhang_domain_nodate})}
		\label{fig:layeredArchitecture}
	\end{figure}
	
	\ac{DDD} ist ein Designansatz, bei dem die Entitäten des Systems, abhängig von dem Input der Domainexperten, modelliert werden.
	Das erleichtert es den Teammitgliedern, die Arbeit der anderen besser zu verstehen.
	Diese Verwendung trägt auch zur \emph{ubiquitous language} bei, die alle Teammitglieder bei Modell- und Entwurfsdiskussionen verwenden können. (\textcite{vernon_implementing_2013})
	
	\autoref{fig:patternsDDD} zeigt alle Komponenten, die bei \ac{DDD} zum Einsatz kommen. 
	In dieser Arbeit fokussieren wir uns speziell auf die folgenden Komponenten:
	
	\begin{itemize}
		\setlength\itemsep{-0.5em}
		\item Entities 
		\item Value-Objects
		\item Aggregates
		\item Repositories
		\item Services
	\end{itemize}
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.32]{assets/componentsDDD.jpg}
		\caption{Komponenten von \ac{DDD} (Quelle: \textcite{xu_ep32_2023})}
		\label{fig:patternsDDD}
	\end{figure}

	
	\section{Planung}
	In diesem Abschnitt geht es hauptsächlich um die Modellierung des Domain-Models von dem \ac{TCMS}.
	Vor der Modellierung wurde eine Übersicht von dem schon bestehenden \acfi{TAS} verschafft (Siehe: \autoref{fig:testAutomationSystem}).
	Durch diese Übersicht wurden die Interaktionen mit dem zu entwickelnden \ac{TCMS} ermittelt.
	Dabei greift das \ac{TAS} über die Technologie \emph{Automise} über eine von \ac{TCMS} bereitgestellte \ac{API} darauf zu und erstellt Testläufe.
	In \autoref{subsec:domainModel} erfolgt eine detaillierte Beschreibung wie das \ac{TAS} Testläufe erstellt (Siehe: \autoref{fig:domainModelPart2}).
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.3]{assets/TestTechnologiesOverview.drawio.png}
		\caption{\ac{TAS} von \ac{GI}}
		\label{fig:testAutomationSystem}
	\end{figure}
	
	\subsection{Domain-Model} \label{subsec:domainModel}
	Zunächst wurde das Domain-Model entwickelt, um die Entitäten und deren Beziehungen darzustellen.
	Dabei wurde exakt darauf geachtet, dass die in \autoref{chapter:requiremnts} ermittelten Anforderungen vollständig abgebildet wurden.

	Die in \autoref{fig:domainModelPart1} abgebildeten Entitäten betreffen folgende Anforderungen:
	
	\begin{itemize}
		%\setlength\itemsep{-0.5em}
		\item RE 1 - Produkt und Testsysteme beschreiben
		
		Das Produkt wurde als \emph{Environment/Platform} (Test-Environment) modelliert.
		Ein Beispiel hierfür wäre ein Gerät von der Firma.
		Das \emph{Testsystem} ist ein Aufbau mit Geräten, die geprüft werden. 
		Beispielsweise ist das eine Prüfwand mit mehreren Geräten mit denen Tests durchgeführt werden.
		Jedes Produkt hat eigene Testsysteme.
		
		\item RE 2 - Features beschreiben und darstellen
		
		Feature wurde als \emph{Testplan/Feature} modelliert.
		Ein Feature besteht aus mehreren Testfällen (Entität Testcase) und bildet ein Feature von einem Gerät ab.
		Ein Beispiel für ein Feature ist die Netzwerk-Connectivity von einem Gerät.
		
		\item RE 3 - Features zu einem Produkt zuordnen
		
		Die erstellten Testpläne können zu Produkten zugeordnet werden.
		Somit können Testpläne für andere Produkte wiederverwendet werden.
		
		\item RE 4 - Testfälle beschreiben und darstellen
		
		Testfall wurde als \emph{Testcase} modelliert.
	    Ein Testfall besteht aus mehreren Testimplementierungen (Entität Testimplementation).
	    Diese Testimplementierungen sind für jeden Testfall einzigartig und können nicht wiederverwendet werden. 
	    Ein Testfall ist beispielsweise eine Überprüfung, ob ein Gerät eine \acfi{DHCP} Adresse erhalten hat.
		
		\item RE 5 - Testfälle zu einem Feature zuordnen
		
		Die Testfälle können zu Features zugeordnet werden.
		Somit können Testfälle für andere Features wiederverwendet werden.
		
		\item RE 6 - Testimplementierungen beschreiben und darstellen
		
		Eine Testimplementierung wurde als \emph{Testimplementation} modelliert.
		Testimplementierungen sind Beschreibungen wie ein Testfall getestet wird und ob dieser manuell oder automatisch ausgeführt wird.
		Testimplementierungen enthalten auch Informationen, ob sie erfolgreich beim letzten Testlauf getestet worden sind.
		Eine Testimplementierungen ist die Beschreibung mit welchen Konfigurationen ein Testfall bei einem Gerät getestet wird.
		
		\item RE 7 - Testimplementierungen zu Testfällen und Testsystemen zuordnen
		
		Testimplementierungen könne zu Testfällen und zu Testsystemen zugeordnet werden.
		Durch die Zuordnung von Testimplementierungen zu Testsystemen ist es möglich die Testimplementierungen von einem Produkt darzustellen.
		Somit können beispielsweise Statistiken und Reports generiert werden, die einen Überblick über jede Testimplementierungen von einem Produkt gibt.
	\end{itemize}

	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.6]{assets/TCMS_DomainModel_part1.png}
		\caption{Domain-Model (Teil 1) basierend auf den Anforderungen von \autoref{chapter:requiremnts}}
		\label{fig:domainModelPart1}
	\end{figure}

	Die in \autoref{fig:domainModelPart2} abgebildeten Entitäten betreffen folgende Anforderungen:
	
	\begin{itemize}
		%\setlength\itemsep{-0.5em}
		\item RE 8 - Testläufe von Testimplementierungen zu einem Testsystem zuordnen
		
		Ein Testlauf wurden als \emph{TestRun} modelliert.
		Testläufe werden automatisch von dem bereits bestehenden \ac{TAS} der Firma erstellt und beschrieben.
		Diese Testläufe enthalten Informationen welche Testimplementationen, mit welchen Konfigurationen und mit welcher Hardware getestet wurde.
		Testläufe werden zum Zeitpunkt des Erstellens zu den jeweiligen Testsystemen, mit denen diese durchgeführt worden sind, zugeordnet.
		
		\item RE 9 - Resultate von bestimmten Testläufen abzufragen
		
		Durch die Zuordnung von Testläufen zu Testsystemen können Resultate zu jedem Testsystem abgefragt werden.
	\end{itemize}

	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.6]{assets/TCMS_DomainModel_part2.png}
		\caption{Domain-Model (Teil 2) basierend auf den Anforderungen von \autoref{chapter:requiremnts}}
		\label{fig:domainModelPart2}
	\end{figure}
	
	Die in \autoref{fig:domainModelPart1} und \autoref{fig:domainModelPart2} gezeigten Entitäten wurden auf Basis der Kommunikation mit Domainexperten modelliert.
	
	
	
	\chapter{Technische Umsetzung}
	Dieses Kapitel beschreibt die Implementierung der definierten User-Stories mit den gewählten Technologien und wie diese mit der entworfenen Architektur umgesetzt wurden. 
	Zuerst wird der allgemeine Ablauf des verwendeten Scrum-Prozesses beschrieben und im Anschluss detailliert auf die User-Stories eingegangen. 

	\section{Scrum}
	Scrum ist eine Projektmanagement-Methode zur Unterstützung der agilen Softwareentwicklung.
	Bei dieser Methode geht es darum, dass ein Team Teilaufgaben von einer komplexen Aufgabenstellung in kleinen Schritten, sogenannte \emph{Sprints}, angeht. (\textcite{rubin_essential_2012})
	
	Für die Implementierung der User-Stories wurde der in \autoref{fig:scrum-process} gezeigte Prozess angewendet.
		
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.35]{assets/scrum-process.png}
		\caption{Scrum Prozess (Quelle: \textcite{noauthor_home_nodate})}
		\label{fig:scrum-process}
	\end{figure}
	
	
	\section{Implementierung der User-Stories}
	Dieser Abschnitt zeigt den Ablauf der Implementierung der User-Stories.
	Die Implementierung ist auf vier User-Stories aufgeteilt, die in der folgenden Reihenfolge implementiert wurden:
	
	\begin{itemize}
		\item Projekt und Datenbank Aufsetzen
		\item Erstellen und suchen von Test-Environments
		
		Um die Durchgängigkeit der Architektur zu veranschaulichen, wird bei dieser User-Story detailliert auf jede Schicht eingegangen.
		Eine detaillierte Beschreibung erfolgt in \autoref{subsec:createAndSearchTestEnvironments}.
		Dabei wurden die User-Stories in folgender Reihenfolge in die Schichten implementiert:
		
		\begin{itemize}
			\setlength\itemsep{-0.5em}
			\item Domainschicht
			\item Infrastrukturschicht
			\item Applikationsschicht
			\item Präsentationsschicht
		\end{itemize}
	
		\item Erstellen und suchen von Testplänen, Testfällen und Testimplementationen
		
		Nachdem die Durchgängigkeit der Architektur gezeigt wurde, wird bei dieser User-Story detailliert auf die Tabellen Konfigurationen mit \ac{EF} Core eingegangen. 
		Eine detaillierte Beschreibung erfolgt in \autoref{subsec:createAndSearchTestplans}.
		
		\item Erstellen und suchen von Testläufe
		
		In dieser User-Story wird gezeigt, wie das \ac{TAS} von \ac{GI} mit dem \ac{TCMS} interagiert (Siehe: \autoref{subsec:createAndSearchTestruns} auf \autopageref{subsec:createAndSearchTestruns}).
	\end{itemize}

	Für die Umsetzung des \ac{TCMS} kommt die Version .NET 7.0 zum Einsatz.
	Als \acfi{IDE} wurde \emph{Rider} von \emph{JetBrains} verwendet.


	\subsection{Projekt und Datenbank Aufsetzen}
	Damit eine Grundlage für die folgenden User-Stories vorhanden ist, wurde die Struktur des Projektes in vier Teilprojekte aufgeteilt.
	Dabei repräsentiert jedes Projekt eine Schicht der verwendeten Architektur.
	
	Für das Aufsetzen der Datenbank wurde das von Docker bereitgestellte Tool \emph{Docker Desktop} verwendet.
	Docker Desktop ist eine Anwendung die das Erstellen und Verwalten von Container einfacher macht. (\textcite{noauthor_docker_2022})
	
	\autoref{lst:dockerDesktop} zeigt das Erstellen und Ausführen eines MariaDB Containers.
	Nachdem der Container hochgefahren ist, kann mit dem MariaDB Server gearbeitet werden.
	
	\begin{listing}[ht]
		\begin{minted}{Basic}
			docker run --name mariadb-container 
			-e MYSQL_ROOT_PASSWORD=admin -p 3306:3306 -d mariadb:latest
		\end{minted}
		\caption{Starten eines MariaDB Containers}
		\label{lst:dockerDesktop}
	\end{listing}

	\autoref{lst:createAndUseDBSchema} zeigt das Erstellen eines Datenbankschemas namens \emph{tcms\_mariadb}. 
	In dieser werden die Tabellen vom \ac{TCMS} erzeugt und verwaltet.
	
	\begin{listing}[ht]
		\begin{minted}{SQL}
			CREATE DATABASE tcms_mariadb; 
			USE tcms_mariadb;
		\end{minted}
		\caption{Erstellen und verwenden eines Datenbankschemas}
		\label{lst:createAndUseDBSchema}
	\end{listing}

	Um eine Verbindung zur Datenbank herzustellen, liegt im Projekt ein \ac{JSON}-File, das die benötigten Konfigurationen bereitstellt (Siehe: \autoref{lst:connectionConfigs}).
	Diese werden beim Start des Projektes in der \emph{Startup} Klasse gelesen und verwendet (Siehe: \autoref{lst:registerDatabase}).
	Weiters wird in \autoref{lst:registerDatabase} gezeigt, dass die Funktion \emph{AddDbContext} den Typ \emph{EFContext} bekommt. 
	Diese Klasse kümmert sich um die Konfiguration aller Tabellen, die verwendet werden (Siehe: \autoref{lst:efcontextClass}).
	
	\autoref{lst:startupClassPart1}, \ref{lst:startupClassPart2} und \ref{lst:programClass} im Anhang zeigt die \emph{Startup} und \emph{Program} Klasse, die für die Initiierung der Datenbank und Tabellen, der \ac{DI} Container und Generierung der Swagger \ac{UI} zuständig sind.

	\begin{listing}[ht]
		\begin{minted}{JSON}
			{
				[...]
				
				"ConnectionStrings": {
					"MariaDbConnectionString": 
					"server=localhost;port=3306;database=tcms_mariadb;user=root;password=admin;"
				}
			}
		\end{minted}
		\caption{Ausschnitt der Konfigurationen für die Verbindung zur MariaDB Datenbank}
		\label{lst:connectionConfigs}
	\end{listing}

	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]
			
			services.AddDbContext<EFContext>(dbContextOptions => {
				var connectionString = _config
					.GetConnectionString("MariaDbConnectionString");
				
				dbContextOptions
					.UseMySql(connectionString,
						ServerVersion.AutoDetect(connectionString));
			});
			
			[...]
		\end{minted}
		\caption{Ausschnitt der \emph{Startup} Klasse, der das Registrieren der Datenbank zeigt}
		\label{lst:registerDatabase}
	\end{listing}

	\subsection{Erstellen und suchen von Test-Environments} \label{subsec:createAndSearchTestEnvironments}
	Zuerst erfolgte die Implementierung der Domain-Models, \emph{Test-Environment} und \emph{Testsystem}, in der Domainschicht.
	Im Anschluss wurden die Interfaces für die Infrastrukturschicht definiert, die ebenfalls in der Domainschicht liegen.
	Somit kann die Infrastrukturschicht einfach und ohne Abhängigkeiten ausgetauscht werden.
	
	Als nächster Schritt wurden das definierte Interface (Siehe: \autoref{lst:testEnvironmentRepository}) in der Infrastrukturschicht implementiert.

	\begin{listing}[ht]
		\begin{minted}{csharp}
			public interface ITestEnvironmentRepository
			{
				string NextIdentity();
				Task<TestEnvironment> FindById(string id);
				Task<List<TestEnvironment>> FindByShortDescription(string shortDescription);
				Task<List<TestEnvironment>> GetAll();
				Task Add(TestEnvironment testEnvironment);
				Task Remove(string id);
				Task Update(TestEnvironment testEnvironment);
			}
		\end{minted}
		\caption{Test-Environment Aggregate Interface, für die Infrastrukturschicht}
		\label{lst:testEnvironmentRepository}
	\end{listing}

	Mithilfe der \ac{ORM} Technologie \ac{EF} Core, können Objekte ohne \ac{SQL} Statements in die Datenbank geschrieben, gelesen, gelöscht und aktualisiert werden.
	\autoref{lst:testEnvironmentRepositoryAusschnitt_1} zeigt wie ein Test-Environment mit einer \acfi{ID} von der Datenbank ausgelesen werden kann.
	
	Damit wir das von \autoref{lst:testEnvironmentRepositoryAusschnitt_1} ausgelesene Test-Environment-Objekt weiter verwenden können, wurde ein \emph{TestEnvironmentService} in der Applikationsschicht implementiert. 
	Dabei wird für den Service sowohl ein Interface definiert als auch eine implementierende Klasse \emph{TestEnvironmentService} realisiert.
	
	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]
			
			public async Task<TestEnvironment> FindById(string id)
			{
				var testEnvironment = await _context.TestEnvironments
					.Include(te => te.TestSystems)
					.Include(tp => tp.TestEnvironmentPlans)
					.FirstOrDefaultAsync(testEnvironment => testEnvironment.DomainId == id);
				
				[...]
				
				return testEnvironment;
			}
		
			[...]
		\end{minted}
		\caption{Ausschnitt der \emph{TestEnvironmentRepository} Klasse, die ein Test-Environment-Objekt mithilfe einer \ac{ID} von der Datenbank ausliest}
		\label{lst:testEnvironmentRepositoryAusschnitt_1}
	\end{listing}
	
	Der in \autoref{lst:testEnvironmentServiceAusschnitt} gezeigte Code bekommt das Test-Environment-Objekt von der Infrastrukturschicht zurück und wandelt es in ein \acfi{DTO} um.
	Das \ac{DTO} wird anschließend von der Applikationsschicht in die Präsentationsschicht weitergeleitet.
	
	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]
			
			public async Task<TestEnvironmentDTO> FindById(string id)
			{
				var testEnvironment = await _testEnvironmentRepository.FindById(id);	
				return new TestEnvironmentDTO
				{
					Id = testEnvironment.DomainId,
					ShortDescription = testEnvironment.ShortDescription,
					LongDescription = testEnvironment.LongDescription,
					[...]
				};
			}
			
			[...]
		\end{minted}
		\caption{Ausschnitt der \emph{TestEnvironmentService} Klasse}
		\label{lst:testEnvironmentServiceAusschnitt}
	\end{listing}

	Der in \autoref{lst:testEnvironmentControllerAusschnitt_1} gezeigte Code bekommt das umgewandelte Test-Environment-Objekt (\ac{DTO}) von der Applikationsschicht zurück und schickt es dem Client weiter.
	
	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]
			
			[HttpGet("{id}")]
			public async Task<ActionResult<TestEnvironmentDTO>> 
				FindTestEnvironmentById(string id)
			{
				var testEnvironmentDTO = await _testEnvironmentService.FindById(id);
				return Ok(testEnvironmentDTO);
			}
			
			[...]
		\end{minted}
		\caption{Ausschnitt der \emph{TestEnvironmentController} Klasse}
		\label{lst:testEnvironmentControllerAusschnitt_1}
	\end{listing}
	
	Der oben gezeigte Ablauf beschreibt die Suche nach einem Test-Environment. 
	Beim Erstellen passiert ähnliches, nur dass der Client ein \ac{DTO} über den bereitgestellten Endpunkt der \ac{API} schickt.
	Die \emph{TestEnvironmentController} Klasse empfängt das \ac{DTO} und schickt es der Applikationschicht weiter, diese Schicht wandelt es von einem \ac{DTO} in ein Domain-Objekt um und schickt es weiter zur Infrastukturschicht, die es dann persistiert.
	
	\newpage
	Der in \autoref{lst:testEnvironmentRepositoryAusschnitt_2} gezeigte Code zeigt das Schreiben eines Test-Environment-Objekts in die Datenbank.
	
	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]
			
			public async Task Add(TestEnvironment testEnvironment)
			{
				await _context.TestEnvironments.AddAsync(testEnvironment);
				await _context.SaveChangesAsync();
			}
			
			[...]
		\end{minted}
		\caption{Ausschnitt der \emph{TestEnvironmentRepository} Klasse}
		\label{lst:testEnvironmentRepositoryAusschnitt_2}
	\end{listing}
	
	\subsubsection{Swagger UI}
	%Abschließend werden die \emph{TestEnvironmentService} und \emph{TestEnvironmentRepository} Klassen in der \emph{EFContext} Klasse (Siehe: \autoref{lst:startupClassPart1}) für den \acfi{DI} Container registriert.
	Dadurch, dass \emph{Swagger} verwendet wird, wird beim Start des Projektes die \emph{TestEnvironmentController} Klasse gescannt und dafür eine Weboberfläche für die definierten Endpunkte generiert (Siehe: \autoref{fig:swaggeruiTestenvironment}).
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.5]{assets/swaggerui_testenvironment.png}
		\caption{Test-Environment \ac{UI} von Swagger}
		\label{fig:swaggeruiTestenvironment}
	\end{figure}
	
	\subsection{Erstellen und suchen von Testplänen, Testfällen und Testimplementationen} \label{subsec:createAndSearchTestplans}
	Wie bei der vorherigen User-Story ist der Ablauf der Implementierung für die Testpläne, Testfälle und für die Testimplementationen der Gleiche.
	
	Zuerst die Domain-Models erstellt, dann das Repository, gefolgt von dem Service und dem Controller.
	Zudem werden beim Start des Projektes die \emph{Controller} Klassen gescannt und eine Weboberfläche generiert.
	Somit ist das Erstellen und Suchen von Testplänen, Testfällen und Testimplementationen auf dem Swagger \ac{UI} verfügbar. 
	
	\subsubsection{Tabellen Konfiguration mit EF Core}
	Damit beispielsweise die Testpläne einer Test-Environment zugewiesen werden können, muss eine \emph{Junction} Tabelle erstellt werden, da zwischen Testplan und Test-Environment eine Many-to-many Beziehung herrscht.
	
	Dadurch, dass eine \emph{Junction} Tabelle benötigt wird, wurde die \emph{TestEnvironmentPlan} Klasse erstellt, die lediglich die Domain-\ac{ID}s beider Domain-Klassen, \emph{TestEnvironment} und \emph{TestPlan}, beinhaltet (Siehe: \autoref{lst:testEnvironmentPlanClass}). 
	Damit die zwei Domain-Klassen später in den \ac{EF} Core Tabellenkonfigurationen als Many-to-many Beziehung konfigurierbar sind, ist die \emph{TestEnvironmentPlan} Klasse als \emph{Property} in beiden Klassen vorhanden.
	
	\begin{listing}[ht]
		\begin{minted}{csharp}
			public class TestEnvironmentPlan
			{
				public string TestEnvironmentDomainId {get; private set;}
				public string TestPlanDomainId {get; private set;}
				
				public TestEnvironmentPlan(string testEnvironmentDomainId, string testPlanDomainId)
				{
					TestEnvironmentDomainId = testEnvironmentDomainId;
					TestPlanDomainId = testPlanDomainId;
				}
			}
		\end{minted}
		\caption{\emph{TestEnvironmentPlan} Klasse}
		\label{lst:testEnvironmentPlanClass}
	\end{listing}
	
	Der in \autoref{lst:testEnvironmentAndPlanConfigurationClass} gezeigte Code konfiguriert einen Teil der Tabellen \emph{TestEnvironment} und \emph{TestPlan}.
	Dadurch wird festgelegt, dass die Tabellen \emph{TestEnvironment} und \emph{TestPlan} eine Many-to-one Beziehung zu der \emph{Junction} Tabelle haben.
	
	Der in \autoref{lst:testEnvironmentPlanConfigurationClass} gezeigte Code konfiguriert einen Teil der \emph{Junction} Tabelle \emph{TestEnvironmentPlan}.
	Dadurch wird festgelegt, dass die \emph{TestEnvironmentPlan} Tabelle eine Many-to-one Beziehung zu den Tabellen \emph{TestEnvironment} und \emph{TestPlan} hat.
	
	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]
			
			builder // TestEnvironment - many to one - TestEnvironmentPlan
				.HasMany(e => e.TestEnvironmentPlans)
				.WithOne()
				.HasPrincipalKey(e => e.DomainId)
				.IsRequired();
				
			[...]
			
			builder // TestPlan - many to one - TestEnvironmentPlan
				.HasMany(e => e.TestEnvironmentPlans)
				.WithOne()
				.HasPrincipalKey(e => e.DomainId)
				.IsRequired();	
				
			[...]
		\end{minted}
		\caption{Ausschnitt aus der \emph{TestEnvironmentConfiguration} und \emph{TestPlanConfiguration} Klasse}
		\label{lst:testEnvironmentAndPlanConfigurationClass}
	\end{listing}

	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]
			
			builder.HasKey(e => new {e.TestEnvironmentDomainId, e.TestPlanDomainId});
			
			builder // TestEnvironmentPlan - many to one - TestEnvironment
				.HasOne<TestEnvironment>()
				.WithMany(e => e.TestEnvironmentPlans)
				.HasPrincipalKey(e => e.DomainId)
				.IsRequired();
				
			builder // TestEnvironmentPlan - many to one - TestPlan
				.HasOne<TestPlan>()
				.WithMany(e => e.TestEnvironmentPlans)
				.HasPrincipalKey(e => e.DomainId)
				.IsRequired();
			
			[...]
		\end{minted}
		\caption{Ausschnitt aus der \emph{TestEnvironmentPlanConfiguration} Klasse}
		\label{lst:testEnvironmentPlanConfigurationClass}
	\end{listing}
	
	Dadurch ergibt sich eine Many-to-Many Beziehung und es wird ermöglicht, dass Testpläne zu einem Test-Environment zuweisbar sind.
	
	Um ein Test-Environment und dazugehörige Testpläne abzufragen, wurde eine \emph{TestEnvironmentManager}-Klasse in der Applikationsschicht implementiert.
	Diese Klasse hat Zugriff auf die \emph{TestEnvironmentRepository}- und \emph{TestPlanRepository}-Klassen.
	\autoref{lst:testEnvironmentManagerClass} im Anhang zeigt, wie dies erfolgt.
	
	\newpage
	\subsection{Erstellen und suchen von Testläufe} \label{subsec:createAndSearchTestruns}
	
	Der Ablauf der Implementierung erfolgte analog zu den vorherigen User-Stories.
	Die \ac{EF} Core Konfiguration besteht aus folgenden Beziehungen:
	
	\begin{itemize}
		\item Many-to-one zu der \emph{Testsystem} Domain-Klasse
		
		Dadurch wird ermöglicht, dass alle Testläufe eines Testsystems von einem Test-Environment abgefragt werden können.
		
		\item One-to-many zu der \emph{ResultDetails} ValueObject-Klasse
		\item One-to-many zu der \emph{DeviceDetail} ValueObject-Klasse
	\end{itemize}
	
	\autoref{lst:testRunConfigurationClass} zeigt wie ein \emph{Dictionary} mit \ac{EF} Core konfiguriert wird.
	Dabei wird das \emph{Dictionary} als \ac{JSON} in eine \ac{JSON}-Spalte geschrieben.
	Beim Auslesen wird das \ac{JSON}-Objekt wieder in ein \emph{Dictionary} deserialisiert.
	
	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]
			
			builder
				.Property(p => p.ResultDetailsMap)
				.HasConversion<string>(
					d => JsonConvert.SerializeObject(d),
					s => JsonConvert.DeserializeObject<Dictionary<string, ResultDetails>>(s) ??
						new Dictionary<string, ResultDetails>()
			);
			
			[...]
		\end{minted}
		\caption{Ausschnitt aus der \emph{TestRunConfiguration} Klasse}
		\label{lst:testRunConfigurationClass}
	\end{listing}
	
	Die Testimplementationen sind, wie die Testläufe, in einer Many-to-one Beziehung zu der \emph{Testsystem}-Klasse. 
	Dadurch ist es möglich, anhand des Status der Testimplementationen, Statistiken und Reports zu erstellen, die angeben in welchem Zustand ein Feature (Testplan) eines Gerätes (Test-Environment) ist und ob es Release bereit ist.
	
	\subsubsection{Automatische Erstellung von Testläufen über das TAS}
	Über bereitgestellte \ac{API}s ermöglicht das \ac{TCMS} dem \ac{TAS} von \ac{GI} Testläufe automatisch zu erstellen.
	Ein Ablauf eines \ac{TAS} sieht wie folgt aus:
	
	\begin{itemize}
		\item Ein Testlauf wird beim Start des \ac{TAS} erstellt.
		
		Jeder Test des \ac{TAS} beinhaltet eine \ac{ID} von einer Testimplementation.
		
		\item Nach Beendigung eines Tests benachrichtigt das \ac{TAS}, über eine bereitgestellte \ac{API}, das \ac{TCMS}
		
		Der Testlauf der beim Start erstellt wurde, wird nun aus der Datenbank ausgelesen. 
		Die Resultate, die das \ac{TAS} mit der zugehörigen Testimplementation \ac{ID} sendet, wird in das \emph{Dictionary}, welches von der \emph{Testlauf}-Klasse, hinzugefügt.
		Der Testlauf wird anschließend in der Datenbank aktualisiert.
		
		\item Nach Beendigung des gesamten Testablaufs wird das Enddatum beim Testlauf eingetragen.
	\end{itemize}
	
	Testläufe können auch manuell über die Swagger-\ac{UI} erstellt werden.
	
	\chapter{Evaluierung und Ausblick}
	Abschließend befasst sich dieses Kapitel mit den Verbesserungsmöglichkeiten der technischen Umsetzung des \ac{TCMS} Backends.
	Weiters wird ein kurzer Ausblick in die Zukunft des \ac{TCMS} gegeben.
	
	\section{Verbesserungsmöglichkeiten}
	In diesem Abschnitt werden potenzielle Verbesserungsmöglichkeiten für die umgesetzte Lösung erläutert.
	Obwohl die Umsetzung die Ziele dieser Arbeit erreicht hat, ist es wichtig mögliche Optimierungen und Verbesserungen der bestehenden Lösung zu veranschaulichen, da dadurch potenzielle Unschönheiten, Codeverdoppelungen etc. aufgedeckt werden können und sich dadurch der Wert des Projektes steigert.
	Folgend gibt es zwei Möglichkeiten Codeverdoppelungen und Unschönheiten zu vermindern.

	\subsection{Basis Klassen}
	Bei der Implementierung der User-Stories wurde ersichtlich, dass einige Funktionalitäten, wie z.B. \autoref{lst:testEnvironmentRepository} zeigt, für mehrere Domain-Objekte wie beispielsweise \emph{TestEnvironment}, \emph{TestPlan} etc. gleich ist.
	Um das zu verhindern, könnten Basis-Klassen in der Infrastruktur- und Applikationsschicht verwendet werden.
	Beispielsweise könnten die Klassen \emph{TestEnvironmentRepository} und \emph{TestPlanRepository} Basisfunktionalitäten Generisch von einer Basis-Klasse vererben.
	Somit könnte ein großer Teil der Codebase verkleinert werden.
	
	\subsection{Automapper}
	Bei der Entwicklung der \emph{Controller}-Klassen ist aufgefallen, dass die Umwandlung von \ac{DTO}s in Domain-Objekte und umgekehrt oft mehrfach in verschiedene Funktionalitäten gleich funktioniert.
	Eine Third-Party Bibliothek names \emph{AutoMapper} könnte die Umwandlungen um einiges vereinfachen. \textcite{noauthor_automapper_nodate}
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.3]{assets/AutoMapper_example.png}
		\caption{Funktionsweise von \emph{AutoMapper} (Quelle: \textcite{sanjay_implement_2020})}
		\label{fig:autoMapperExample}
	\end{figure}

	\autoref{fig:autoMapperExample} zeigt wie \ac{DTO}s zu Domain-Objekte mit \emph{AutoMapper} umgewandelt werden können.
	Somit wird die Übersichtlichkeit des Codes verbessert und eventuell Codeverdoppelung verhindert.
	
	\section{Ausblick}
	Die technische Umsetzung des \ac{TCMS} Backends in Zusammenarbeit mit \emph{\acl{GI}} war der erste Schritt zur Realisierung eines Vollständigem \emph{\acl{TCMS}s}.
	
	Aus der Sicht des Backends werden in Zukunft die oben aufgelisteten Verbesserungsmöglichkeiten implementiert und gegebenenfalls weitere Features eingebaut.
	Weiters wird ein Frontend mit den Technologien \emph{React} und \emph{TypeScript}, auf Basis dieser Arbeit, entwickelt.
	
	Dadurch wird es die Möglichkeit geben über eine Weboberfläche Statistiken und Reports über gesamte Systeme und Geräte erstellen zu lassen, die wertvollen Einblick geben, welche Features getestet und Release bereit sind.
	
	\chapter{Zusammenfassung}
	Ziel dieser Arbeit war es ein funktionierendes \ac{TCMS} Backend zu implementieren. 
	Anhand der Kommunikation mit den Domainexperten sind die aufgelisteten Kriterien in \autoref{chapter:requiremnts} auf \autopageref{chapter:requiremnts} entstanden.
	Durch diese Kriterien wurde dann entsprechend ein Domain-Model erstellt, das die angegebenen Kriterien vollständig abgedeckt hat.
	Folgend darauf wurden in \autoref{sec:userStoriesDefinition} auf \autopageref{sec:userStoriesDefinition} die User-Stories für die Umsetzung der gegebenen Anforderungen geplant.	
	
	Mit den beschriebenen Technologien in \autoref{sec:technologies} auf \autopageref{sec:technologies} erfolgte eine dementsprechende Umsetzung eines \ac{TCMS} Backends.
	Angefangen mit der User-Story \emph{Erstellen und suchen von Test-Environments}, ist die vierschichtige Architektur implementiert worden.
	Darauffolgend konnten, mithilfe dieser Architektur, mit wenig Aufwand die restlichen User-Stories implementiert werden.
	
	Betrachtet man die Ergebnisse der technischen Umsetzung\footnote{https://github.com/iiNomad23/FHV\_BachelorThesis} kann für die vierschichtigen Architektur und den angewendeten Technologien eine Empfehlung ausgesprochen werden. 
	Entwickler:innen die Erfahrung mit den genannten Technologien und der Architektur haben können damit einfach und effizient ein eigenes \ac{TCMS} Backend entwickeln.
	
	Abschließend lässt sich sagen, dass die vorgenommenen Ziele erfolgreich umgesetzt worden sind und die anfangs gestellten relevanten Fragen, unterstützend mit der Umsetzung, beantwortet sind.
	
	
	% Literaturverzeichnis
	\clearpage
	\phantomsection
	\addcontentsline{toc}{chapter}{Literaturverzeichnis}
	\printbibliography
	
	% Anhang
	\chapter*{Anhang}
	\addcontentsline{toc}{chapter}{Anhang}
	\begin{listing}[ht]
		\begin{minted}{csharp}
			public class Startup
			{
				private readonly IConfiguration _config;		
				
				public Startup(IConfiguration config) { _config = config; }
				
				// This method gets called by the runtime. 
				// Use this method to add services to the container.
				public void ConfigureServices(IServiceCollection services)
				{
					// Register database with the DI container
					services.AddDbContext<EFContext>(dbContextOptions => {
						var connectionString = _config
							.GetConnectionString("MariaDbConnectionString");	
									
						dbContextOptions
							.UseMySql(connectionString,
								ServerVersion.AutoDetect(connectionString));
					});
					
					// Register repositories with the DI container
					services.AddTransient<ITestCaseRepository, TestCaseRepository>();
					services.AddTransient<ITestPlanRepository, TestPlanRepository>();
					[...]
					
					// Register services with the DI container
					services.AddTransient<ITestCaseService, TestCaseService>();
					services.AddTransient<ITestPlanService, TestPlanService>();
					[...]
					
					services.AddControllers();
					services.AddSwaggerGen(c => { 
							c.SwaggerDoc("v1", 
								new OpenApiInfo { Title = "API", Version = "v1" }); 
					});
				}
				
			[...]
		\end{minted}
		\caption{\emph{Startup} Klasse Teil 1}
		\label{lst:startupClassPart1}
	\end{listing}

	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]
				
				// This method gets called by the runtime. 
				// Use this method to configure the HTTP request pipeline.
				public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
				{
					if (env.IsDevelopment())
					{
						app.UseDeveloperExceptionPage();
						app.UseSwagger();
						app.UseSwaggerUI(c => 
							c.SwaggerEndpoint(
								"/swagger/v1/swagger.json", 
								"API v1"
							)
						);
					}
					
					app.UseHttpsRedirection();
					app.UseRouting();
					app.UseAuthorization();
					app.UseEndpoints(endpoints => { endpoints.MapControllers(); });
				}
			}
		\end{minted}
		\caption{\emph{Startup} Klasse Teil 2}
		\label{lst:startupClassPart2}
	\end{listing}

	\begin{listing}[ht]
		\begin{minted}{csharp}
			public class Program
			{
				public static void Main(string[] args)
				{
					// Use this line of code when we are going production
					// CreateHostBuilder(args).Build().Run();
					
					// Remove the code block below when we are going production
					var host = CreateHostBuilder(args).Build();	
					using (var scope = host.Services.CreateScope())
					{
						var services = scope.ServiceProvider;
						var dbContext = services.GetRequiredService<EFContext>();
						dbContext.Database.EnsureDeleted();
						dbContext.Database.EnsureCreated();
					}
					
					host.Run();
				}
				
				private static IHostBuilder CreateHostBuilder(string[] args)
				{
					return Host
						.CreateDefaultBuilder(args)
						.ConfigureWebHostDefaults(webBuilder => { 
							webBuilder.UseStartup<Startup>(); 
						});
				}
			}
		\end{minted}
		\caption{\emph{Program} Klasse, die die \emph{Startup} Klasse verwendet}
		\label{lst:programClass}
	\end{listing}

	\begin{listing}[ht]
		\begin{minted}{csharp}
			public class EFContext : DbContext
			{
				public DbSet<TestCase> TestCases { get; set; }
				public DbSet<TestPlan> TestPlans { get; set; }
				public DbSet<TestImplementation> TestImplementations { get; set; }
				public DbSet<TestRun> TestRuns { get; set; }
				public DbSet<TestEnvironment> TestEnvironments { get; set; }		
				public DbSet<TestSystem> TestSystems { get; set; }
				[...]
				
				public EFContext(DbContextOptions<EFContext> options) : base(options) { }	
				public EFContext() { }
				
				protected override void OnModelCreating(ModelBuilder modelBuilder)
				{
					base.OnModelCreating(modelBuilder);
					
					ApplyChildConfigurations(modelBuilder);
					
					modelBuilder.ApplyConfiguration(new TestCaseConfiguration());
					modelBuilder.ApplyConfiguration(new TestPlanConfiguration());
					modelBuilder.ApplyConfiguration(new TestImplementationConfiguration());
					modelBuilder.ApplyConfiguration(new TestRunConfiguration());
					modelBuilder.ApplyConfiguration(new TestEnvironmentConfiguration());
					[...]
				}
				
				private static void ApplyChildConfigurations(ModelBuilder modelBuilder)
				{
					modelBuilder.ApplyConfiguration(new TestSystemConfiguration());
					modelBuilder.ApplyConfiguration(new TestEnvironmentPlanConfiguration());
					[...]
				}
			}
		\end{minted}
		\caption{
			\emph{EFContext} Klasse, die \ac{EF} Core verwendet, um die Tabellen zu erstellen. 
			Diese Klasse wird, bei der Registrierung der Datenbank, in \autoref{lst:startupClassPart1} als Typ angegeben.
		}
		\label{lst:efcontextClass}
	\end{listing}

	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]
			
			public async Task<TestEnvironmentWithTestPlansDTO> FindByIdWithTestPlans(string id)
			{
				var testEnvironment = await _testEnvironmentRepository.FindById(id);
				
				var testEnvironmentPlanIds = testEnvironment.TestEnvironmentPlans
					.Select(item => item.TestPlanDomainId)
					.ToArray();
				
				var testPlans = await _testPlanRepository.FindByIdSet(testEnvironmentPlanIds);
				
				var testPlanDTOs = testPlans
					.Select(tp => new TestPlanDTO
						{
							Id = tp.DomainId,
							ShortDescription = tp.ShortDescription,
							LongDescription = tp.LongDescription,
							ReferenceLink = tp.ReferenceLink
						}
					)
					.ToList();
				
				var testEnvironmentDTO = new TestEnvironmentDTO
				{
					Id = testEnvironment.DomainId,
					ShortDescription = testEnvironment.ShortDescription,
					LongDescription = testEnvironment.LongDescription,
					TestSystems = testEnvironment.TestSystems
						.Select(ts => new TestSystemDTO
							{
								Name = ts.Name,
								Description = ts.Description,
							}
						)
						.ToList()
				};
				
				var testEnvironmentWithTestPlansDTO = new TestEnvironmentWithTestPlansDTO
				{
					TestEnvironmentDTO = testEnvironmentDTO,
					TestPlanDTOs = testPlanDTOs
				};
				
				return testEnvironmentWithTestPlansDTO;
			}
		
			[...]
		\end{minted}
		\caption{Ausschnitt der \emph{TestEnvironmentManager} Klasse die das Interface \emph{ITestEnvironmentManger} implementiert}
		\label{lst:testEnvironmentManagerClass}
	\end{listing}
		
	\clearpage
	\section*{Eidesstattliche Erklärung}
	\addcontentsline{toc}{chapter}{Eidesstattliche Erklärung}
	Ich erkläre hiermit an Eides statt, dass ich vorliegende Bachelorarbeit selbstständig und ohne Benutzung anderer als der angegebenen Hilfsmittel angefertigt habe. 
	Die aus fremden Quellen direkt oder indirekt übernommenen Stellen sind als solche kenntlich gemacht. 
	Die Arbeit wurde bisher weder in gleicher noch in ähnlicher Form einer anderen Prüfungsbehörde vorgelegt und auch noch nicht veröffentlicht.
	
	\vspace{3cm}
	\noindent
	Dornbirn, am \displaydate{date} \hfill Marco Prescher
	
	
\end{document}