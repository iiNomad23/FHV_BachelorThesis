% !TeX document-id = {f5eab2f7-1326-43b3-ac0e-350c2acbded8}

% !TeX TXS-program:compile = txs:///pdflatex/[--shell-escape]

\documentclass[a4paper, fontsize=11pt, parskip=half, twoside, headings=openright]{scrreprt}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}   
\usepackage{graphicx}       
\usepackage[english, ngerman]{babel}
\usepackage{csquotes} % for displaying quotes  
\usepackage{acronym}
\usepackage{eurosym}
\usepackage[linktocpage=true]{hyperref}
\usepackage{xurl}
\usepackage[bindingoffset=8mm]{geometry}
\usepackage{caption}
\captionsetup{format=hang, justification=raggedright}
\usepackage[style=authoryear, backend=biber]{biblatex}
\usepackage{float}
\usepackage{rotating}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{outlines} % for nested lists
\usepackage{tikz} % for drawing
\usepackage{microtype} % improve micro typography for better distribution
\usepackage{minted} % for source code
\usepackage{caption} % caption for e.g. figures
\usepackage{subcaption} % captions for multiple figures
\usepackage{datetime} % for custom dates
\usepackage[german]{cleveref} % clever refs - set labels as always (\label{fig:hello}), \cref{fig:hello}
\usepackage[onehalfspacing]{setspace} % 1.5x line space

% adds generic commands for degree, ohm, ..
\usepackage{textcomp}
\usepackage{gensymb}

\usepackage{todonotes}

% custom commands
\renewcommand{\listingscaption}{Quellcode}
\renewcommand{\listoflistingscaption}{Quellcodeverzeichnis}
\providecommand*{\listingautorefname}{Quellcode}

\definecolor{bg}{rgb}{0.93, 0.93, 0.93}
\setminted{
	autogobble, 
	tabsize=4, 
	numbers=left,
	numbersep=15pt,
	bgcolor=bg,
	fontsize=\footnotesize
}
\renewcommand{\fcolorbox}[4][]{#4} % "disables" syntax errores in minted code blocks 

% define date variable for whole doc
% use \displaydate{date} where needed to insert this date

\newdate{date}{20}{05}{2023}
\date{\displaydate{date}}

% add zotero file for citations
\addbibresource{reference.bib}

\begin{document}
	
	% Titelblatt
	%\pagenumbering{roman}
	
	\begin{titlepage}
		\begin{flushright}
			\includegraphics[width=0.4\linewidth]{assets/FHV_FHV-Logo.png}
		\end{flushright}
		
		\vspace{1cm}	
		\begin{flushleft}
			\section*{Entwicklung eines Test Case Management Systems für Gantner Instruments Messsysteme}
			%\subsection*{\papersubtitle}
			
			\vspace{1cm}
			Bachelorarbeit\newline
			zum Erlangen des akademischen Grades\newline
			
			\vspace{0.5cm}
			\textbf{Bachelor of Science in Engineering (BSc)}
			
			\vspace{1cm}
			Fachhochschule Vorarlberg\newline
			Informatik - Software and Information Engineering\newline
			
			\vspace{1cm}
			Betreut von\newline
			Dipl.-Ing. Dr. techn. Ralph Hoch
			
			\vspace{0.5cm} 
			Vorgelegt von\newline
			Marco Prescher	
			
			\vspace{0.5cm}
			Dornbirn, am \displaydate{date}
		\end{flushleft}
	\end{titlepage}
	
	% Kurzreferat
	%\newpage
	\cleardoublepage
	\section*{Kurzreferat}
	\subsection*{Entwicklung eines Test Case Management Systems für Gantner Instruments Messsysteme}
	
	Die Entwicklung technischer Systeme ist ein komplexer und kostspieliger Prozess. 
	Daher ist es wichtig, dass die Produkte vor der Auslieferung an die Kundschaft gezielt und sorgfältig getestet werden. 
	Dies wird durch knappe Ressourcen und Termindruck oftmals vernachlässigt, oder nur unzureichend durchgeführt. 
	
	Durch ein Test Case Management System ist es möglich, dass Features vor dem Release eines Produkts getestet und abgenommen werden müssen. 
	Das wiederum ermöglicht, dass neu implementierte Features gründlich getestet werden und somit zu einer hohen Qualität des Produkts beitragen.
	Dadurch kann stabile Hardware sowie effiziente und gut strukturierte Software an die Kundschaft ausgeliefert werden.
	
	Ziel dieser Arbeit ist es, ein Test Case Management System zu entwickeln, mit dem es möglich ist Features von Messsystemen der Firma Gantner Instruments zu beschreiben.
	Zusätzlich soll das Test Case Management System in der Lage sein, Testergebnisse von einem bereits bestehenden Test Automation System zu empfangen und diesen Features zuzuordnen.
	
	Das in dieser Arbeit entwickelte Test Case Management System ermöglicht eine präzise Beschreibung von Features und Testergebnissen sowie deren Speicherung in einer Datenbank. 
	Über eine standardisierte API können Daten aus dem System abgefragt und von externen Systemen verarbeitet werden. 
	Durch sorgfältige Dokumentation von Features und Testergebnisse können Statistiken und Reports erstellt werden, die wiedergeben, welche Features erfolgreich getestet wurden.
	Dadurch ist eine Überwachung des Testfortschritts möglich und es kann anhand von Zielvorgaben festgestellt werden, welche Features Release-fähig sind und in das Produkt mit übernommen werden können.
	
	% Abstract
	%\newpage
	\cleardoublepage
	\section*{Abstract}
	\subsection*{Development of a Test Case Management System for Gantner Instruments Measurement Systems}
	
	The development of technical systems is a complex and costly process. 
	It is therefore important that the products are tested specifically and carefully before delivery to the customer. 
	Due to scarce resources and deadline pressure, this is often neglected, or only carried out inadequately. 
	
	A Test Case Management System makes it possible for features to be tested and approved before a product is released. 
	This in turn enables newly implemented features to be thoroughly tested, thus contributing to the high quality of the product.
	As a result, stable hardware as well as efficient and well-structured software can be delivered to the customer.
	
	The goal of this thesis is to develop a Test Case Management System, which makes it possible to describe features of measurement systems of the company Gantner Instruments.
	In addition, the Test Case Management System should be able to receive test results from an already existing test automation system and assign them to features.
	
	The Test Case Management System developed in this thesis allows a precise description of features and test results as well as their storage in a database. 
	Using a standardized API, data can be retrieved from the system and processed by external systems. 
	By carefully documenting features and test results, statistics and reports can be generated that reflect which features were successfully tested.
	This makes it possible to monitor the progress of testing and to determine, based on target goals, which features are ready for release and can be incorporated into the product.
	
	% Inhaltsverzeichnis
	\cleardoublepage   % force output to a right page
	\setcounter{tocdepth}{2}
	\setcounter{secnumdepth}{4}
	\tableofcontents
	
	% Abbildungsverzeichnis
	\clearpage
	\phantomsection
	\addcontentsline{toc}{chapter}{Abbildungsverzeichnis}
	\listoffigures
	
	% Quellcodeverzeichnis
	\clearpage
	\phantomsection
	\addcontentsline{toc}{chapter}{Quellcodeverzeichnis}
	\listoflistings
	
	% Abkürzungsverzeichnis
	\clearpage
	\phantomsection
	\addcontentsline{toc}{chapter}{Abkürzungsverzeichnis}
	\chapter*{Abkürzungsverzeichnis}
	\begin{acronym}
		\acro{API}{Application Programming Interface}
		\acro{JSON}{JavaScript Object Notation}
		\acro{TCMS}{Test Case Management System}
		\acro{TDD}{Test Driven Development}
		\acro{EF}{Entity Framework}
		\acro{ORM}{Object Relational Mapping}
		\acro{OAS}{OpenAPI Spezifikation}
		\acro{HTTP}{Hypertext Transfer Protocol}
		\acro{MVP}{Minimum Viable Product}
		\acro{UI}{User Interface}
		\acro{DDD}{Domain Driven Design}
		\acro{DHCP}{Dynamic Host Configuration Protocol}
		\acro{GI}{Gantner Instruments}
		\acro{TAS}{Test Automation System}
		\acro{IDE}{Integrated Development Environment}
		\acro{ID}{Identifier}
		\acro{SQL}{Structured Query Language}
		\acro{DTO}{Data Transfer Object}
		\acro{DI}{Dependency Injection}
	
		\acrodefplural{TCMS}{Test Case Management Systeme}
	\end{acronym}
	
	% Inhalt
	\cleardoublepage
	%\pagenumbering{arabic}
	
	\chapter{Einleitung}
	
	\begin{flushright}
		\rightskip=8cm\textit{``Time is money.''} \\
		\vspace{.2em}
		\rightskip=3cm--- Benjamin Franklin (\textcite{franklin_advice_1748})
	\end{flushright}

	In der Softwareentwicklung kann es durch Fehler und Mängel zu Verzögerungen und dadurch in weiterer Folge zu Verlusten kommen.
	Um dieses Risiko zu minimieren, plant die Firma \acfi{GI} ein \acfi{TCMS} einzuführen.
	Diese Arbeit beschäftigt sich mit der Planung und Entwicklung eines \ac{TCMS} und dem Vergleich verschiedener vorhandener Lösungen. 
	Das entwickelte \ac{TCMS} ist dabei speziell auf die Anforderungen von \ac{GI} angepasst.
	
	
	\section{Motivation} \label{sec:motivation}
	Die Entwicklung technischer Systeme ist ein komplexer Prozess, der eine hohe Qualität für das zu entwickelnde System erfordert, um den Anforderungen der Kundschaft gerecht zu werden. 
	Damit diese Qualität auch gewährleistet werden kann, müssen Fehler sowie Mängel identifiziert und ausgebessert werden. 
	Ein \ac{TCMS} bietet eine Lösung, um diesen Prozess zu vereinfachen und effektiver zu gestalten. 
	Durch die Verwendung eines \ac{TCMS} können Angestellte aus verschiedenen Abteilungen, wie zum Beispiel der Software-, Hardware-, Support- oder Marketingabteilung, die Qualität des Produkts gemeinsam verbessern. 
	
	\section{Problemstellung}
	Durch die angesprochene Komplexität technischer Systeme ist bekannt, dass Fehler, die erst spät im Entwicklungsprozess entdeckt werden, viel kostspieliger zu beheben sind als Fehler, die frühzeitig identifiziert und behoben werden. (\textcite{westland_cost_2002})
	
	Infolgedessen suchen Unternehmen nach Lösungen, um den Testprozess effektiver zu gestalten und Fehler früher im Entwicklungszyklus zu identifizieren. 
	\ac{TCMS} bietet eine solche Lösung, indem es Entwicklern und Testern ermöglicht, Testfälle effizient zu planen und zu verwalten sowie Testergebnisse zu erfassen, darzustellen und zu analysieren. 
	Obwohl \ac{TCMS} in der Industrie weit verbreitet sind und einige fertige Lösungen auf dem Markt erhältlich sind, gibt es jedoch nicht immer eine Lösung die einfach in bestehende Systeme oder Entwicklungsprozesse integriert werden kann. 
	Zusätzlich können spezielle firmeninterne Anforderungen oftmals nicht abgedeckt werden.
	Diese Probleme stellen Hindernisse dar, die die Einführung von \ac{TCMS} in einem Unternehmen erschweren. 
	
	\section{Zielsetzung}
	Das Ziel dieser Arbeit ist es, ein \ac{TCMS} zu entwickeln und in die bestehende Infrastruktur von \ac{GI} zu integrieren.
	Zudem wird untersucht was ein \ac{TCMS} auszeichnet und was dieses enthalten soll.
	Hiermit ergeben sich drei relevante Fragen:
	
	\begin{itemize}
		\item Wie kann man Features, Testfälle und Testimplementierungen beschreiben? 
		\item Wie könne diese in Datenbanken zur weiteren Verarbeitung gespeichert werden? 
		\item Wie können Testläufe mit diesen Beschreibungen verknüpft werden?
	\end{itemize}
	
	Insbesondere möchten wir die folgenden Ziele erreichen:
	
	\begin{itemize}
		\item Die Vor- und Nachteile eines \ac{TCMS} zu identifizieren, analysieren und dokumentieren.
		\item Empfehlungen für die erfolgreiche Implementierung und Integration eines \ac{TCMS} in der Softwareentwicklung zu geben, einschließlich der Identifizierung bewährter Praktiken.
	\end{itemize}
	
	Durch die Erfüllung dieser Ziele trägt diese Arbeit bei, das Verständnis für die Verwendung eines \ac{TCMS} in der Produktentwicklung zu verbessern und Unternehmen dabei zu unterstützen, den Testprozess zu optimieren und die Qualität ihrer Produkte zu verbessern.
	
	
	
	\chapter{Stand der Technik}
	Dieses Kapitel gibt einen Überblick über den aktuellen Stand der Technik von Testarten, \ac{TCMS} sowie deren Verwendung und Integration mit bestehenden Systemen. 
	Des Weiteren werden Technologien, auf denen das in dieser Arbeit entwickelte \ac{TCMS} aufbaut, beschrieben.
	
	\section{Testarten} \label{sec:testtypes}
	Während der Entwicklung eines Produkts kommen unterschiedliche Testarten zum Einsatz. 
	\textcite{atlassian_unterschiedlichen_nodate} beschreibt sieben unterschiedliche Testverfahren die verschiedene Aspekte eines Produkts testen.
	In \textcite{noauthor_software_nodate} wird beschreiben, dass dabei zwischen \emph{Funktionalen} und \emph{Nicht-Funktionalen} Tests unterschieden wird.
	Zu der funktionalen Testfamilie zählen beispielsweise Unit-Tests und Integrationstests.
	Nicht funktionale Testarten sind beispielsweise Leistung-, Last-, Stress- oder Usability-Tests.
	
	Einige der am häufigsten vorkommenden Testarten sind:
	
	\begin{itemize}
		\item Unit-Tests
		\item Integrationstests
		\item Funktionstests
		\item Leistungstests
	\end{itemize}
	
	\subsection{Unit-Tests}
	Unit-Tests sind Tests die beispielsweise Methoden einer Klasse mit unterschiedlichen Parametern testen. 
	Sie sind automatisierbar und können von einer Continuous Integration Pipeline durchgeführt werden. 
	Diese Tests ermöglichen eine kontinuierliche Überprüfung einzelner Methoden im Entwicklungsprozess und unterstützen das frühzeitige Finden von Fehlern.
	
	\subsection{Integrationstests}
	Integrationstests sind Tests, die sicherzustellen, dass verschiedene Module oder Services problemlos miteinander interagieren können. 
	Durch diese Tests kann die Funktionalität einzelner Teile der Anwendung überprüft werden, wie beispielsweise die Interaktion mit einer Datenbank oder der Zusammenarbeit von Microservices.
	
	\subsection{Funktionstests}
	Funktionstests werden verwendet, um ausschließlich Ergebnisse einer gegebenen Funktion zu überprüfen.
	Der Unterschied zum Unit-Test ist, dass Funktionstests Spezifikationen überprüfen und Unit-Tests Code.
	Beispielsweise werden Spezifikationen vor der Testausführung festgelegt und diese dann mit den Ergebnissen verglichen.
	
	Während Integrationstests beispielsweise nur prüfen, ob Datenbankabfragen generell möglich sind, wird bei einem Funktionstest ein bestimmter Wert aus der Datenbank abgerufen und dieser mit den angegebenen Spezifikationen geprüft.
	
	\subsection{Leistungstests}
	Leistungstests prüfen das Verhalten eines Systems unter verschiedenen Lastprofilen. 
	Häufig wird Zuverlässigkeit, Geschwindigkeit, Skalierbarkeit und Reaktionsfähigkeit einer Anwendung getestet. 
	Außerdem können Leistungstests mögliche Engpässe in einer Anwendung identifizieren.
	
	
	\section{Black-Box und White-Box Testing}
	Sowohl \emph{Black-Box} als auch \emph{White-Box} Tests werden in der Software Entwicklung häufig verwendet, um Fehler zu identifizieren und die Qualität eines Produkts zu evaluieren. 
	Dabei gibt es zwischen den beiden wichtige Unterschiede wie \autoref{fig:WhiteBoxBlackBoxTesting} veranschaulicht.
	
	Bei White-Box Testing handelt es sich um Unit-Tests die den Code, die Struktur und das Design des zu testeten Produkts überprüfen, wobei der Inhalt des Codes für den Tester einsehbar ist.
	White-Box Testing bezieht sich dabei nur auf die interne Funktion der Software.
	
	Bei Black-Box Testing wird die interne Struktur, das Design und die Implementierung nicht berücksichtigt.
	Hier werden nur die Ausgaben oder Reaktionen von dem System geprüft.
	Black-Box Testing bezieht sich hiermit nur auf die externe Funktion der Software. (\textcite[Seite 12]{nidhra_black_2012})
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.6]{assets/WhiteBoxBlackBoxTesting.jpg}
		\caption{Black-Box/White-Box Testing (Quelle: \textcite{khandelwal_difference_2019})}
		\label{fig:WhiteBoxBlackBoxTesting}
	\end{figure}
	
	
	\section{Test Driven Devlopment}
	\acfi{TDD} ist ein Konzept, bei dem Tests zuerst geschrieben werden und erst anschließend eine passende Implementierung erstellt wird.
	Diese beinhaltet genau soviel, dass der Test erfolgreich durchgeführt werden kann.
	\autoref{fig:tdd-cycle} zeigt einen \ac{TDD} Zyklus.
	\ac{TDD} bietet daher mehrere Vorteile (\textcite{ammann_introduction_2016}):
	
	\begin{itemize}
		\item Geschriebener Code kann überarbeitet oder verschoben werden, ohne dass die Gefahr besteht, Funktionalität zu beschädigen.
		\item Die Tests selbst werden durch die Implementierung getestet.
		\item Die Anforderungen können mit geringerem Aufwand umgesetzt werden, da nur die benötigte Funktion geschrieben wird.
	\end{itemize}
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.25]{assets/tdd-cycle.png}
		\caption{\acl{TDD} cycle (Quelle: \textcite{noauthor_test-driven_nodate})}
		\label{fig:tdd-cycle}
	\end{figure}
	
	\section{Test Case Management System} \label{sec:tcms}
	Ein \acl{TCMS} (\ac{TCMS}) ist eine Software, mit dem Test-Teams für ein bestimmtes Projekt oder eine Anwendung Testfälle verwalten, organisieren und analysieren können.
	Es hilft bei der Planung, Überwachung und Dokumentation von Tests und ermöglicht es, Testfälle sicher und effizient zu verwalten.
	
	Ein \ac{TCMS} ist ein wichtiges Werkzeug, um einen strukturierten und effektiven Testprozess zu gewährleisten und den Qualitätsstandard einer Anwendung zu verbessern.
	Es verfügt über Basisfunktionen wie Testfall-Erstellung, Testfall-Verwaltung, Testfall-Ausführung und Ergebnisberichterstattung. 
	Des Weiteren kann ein solches System auch eine integrierte Umgebung für die Zusammenarbeit von verschiedene Abteilungen in einer Firma bereitstellen.
	
	Zusätzlich zu den Basisfunktionen sind weitere wichtige Merkmale (\textcite{lead_articles_nodate}):
	
	\begin{itemize}
		\item Attraktive Benutzeroberfläche und benutzerfreundliches Design
		\item Nachvollziehbarkeit
		\item verbesserte Zeitplanung und Organisation für Releases durch Reports
		\item Überwachung und Metriken
		\item Flexibilität
	\end{itemize}
	
	
	\subsection{Allgemeine Vorteile von Test Case Management Systemen}
	Einer der Hauptvorteile eines \ac{TCMS} besteht darin, dass sie den Testprozess verbessern. 
	Sie unterstützen auch die Kontrolle der Gesamtkosten, indem sie Testautomatisierung nutzen, um einen reibungslosen Ablauf zu gewährleisten.  
	
	Einige Vorteile von \ac{TCMS} bezüglich der Testausführungsläufe sind (\textcite{lead_articles_nodate}):
	
	\begin{itemize}
		\item Sie geben einen besseren Überblick über das zu testende System, halten den gesamten Prozess auf Kurs und koordinieren die Testaktivitäten.
		\item Sie helfen bei der Feinabstimmung des Testprozesses, indem sie die Zusammenarbeit, Kommunikation und Auswertung unterstützen.
		\item Sie dokumentieren Aufgaben, Fehler sowie Testergebnisse und vereinfachen den Prozess, indem sie alles in einer einzigen Anwendung erledigen.
		\item Sie sind skalierbar und können eingesetzt werden, wenn die Testaktivitäten umfangreicher und komplexer werden.
	\end{itemize}
	
	
	\subsection{Überblick von bestehenden Test Case Management Systemen}
	Auf dem Markt gibt es eine Vielzahl fertiger und direkt verwendbarer \ac{TCMS}, die die Verwaltung von Tests vereinfachen.
	
	Einige bekannte \ac{TCMS} sind in \autoref{fig:tcms_logo} dargestellt und hier aufgelistet:
	
	\begin{itemize}
		\item \textcite{noauthor_testrail_2023} 
		
		Webbasiertes \ac{TCMS}, ist zentralisiert und hat folgende Features:
		
		\begin{itemize}
			\setlength\itemsep{-0.5em}
			\item Test-Planung, -Verwaltung und -Ausführung 
			\item Echtzeit Berichterstattung und Analysen
			\item Rückverfolgbarkeits- und Abdeckungsberichte für Anforderungen, Tests und Fehler
		\end{itemize}
		
		\item \textcite{noauthor_practitest_nodate} 
		
		Webbasiertes \ac{TCMS} und hat folgende Features:
		
		\begin{itemize}
			\setlength\itemsep{-0.5em}
			\item Test-Planung, -Verwaltung und -Ausführung 
			\item Echtzeit Test Status Update
			\item Berichterstattung
			\item Dashboards
			\item Integrationsmöglichkeit mit Automation Tools
		\end{itemize}
		
		\item \textcite{noauthor_zephyr_nodate} 
		
		Webbasiertes \ac{TCMS}, kann in JIRA integriert werden und hat folgende Features:
		
		\begin{itemize}
			\setlength\itemsep{-0.5em}
			\item Test-Planung, -Verwaltung und -Ausführung 
			\item Test Automatisierung
			\item Echtzeit Visualisierung von Projektstatus
		\end{itemize}
		
		\item \textcite{noauthor_tricentis_nodate} 
		
		Webbasiertes \ac{TCMS} und hat folgende Features:
		
		\begin{itemize}
			\setlength\itemsep{-0.5em}
			\item Test-Planung, -Verwaltung und -Ausführung 
			\item Migrationsmöglichkeit von alten Testmanagement-Lösungen
			\item Integrationsmöglichkeit mit Jenkins, Azure Pipelines, Bamboo oder jedem anderen CI/CD-Tool
			\item Anpassbare Dashboards, um über alle Releases, Projekte oder Programme im gesamten Unternehmen zu berichten
			\item Berichte per E-Mail oder URL teilen
		\end{itemize}
	\end{itemize}
	
	Welches Tool am besten geeignet ist, hängt dabei von der jeweiligen Anwendung und den spezifischen Anforderungen ab.
	\newline
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.5]{assets/best-tool-logos.jpg}
		\caption{Liste von aktuell führenden Test Case Management Systemen/Tools (Quelle: \textcite{noauthor_7_nodate})}
		\label{fig:tcms_logo}
	\end{figure}
	 
	
	\section{Verwendete Technologien} \label{sec:technologies}
	Dieser Abschnitt gibt eine Übersicht über die verwendeten Technologien, die für die Implementierung des in dieser Arbeit entwickelten \ac{TCMS} eingesetzt worden sind.
	
	\subsection{MariaDB}
	MariaDB ist eine weit verbreitete relationale Open-Source-Datenbanken. 
	Sie wurde auf einem Fork von MySQL basierend von den ursprünglichen Entwicklern von MySQL entwickelt. 
	Der Fokus von MariaDB liegt auf Leistung, Stabilität und Offenheit. 
	Zu den jüngsten Erweiterungen gehören Clustering mit Galera Cluster 4, Kompatibilitätsfunktionen mit der Oracle-Datenbank und temporäre Datentabellen, mit denen Daten zu jedem beliebigen Zeitpunkt in der Vergangenheit abgefragt werden können. (\textcite{noauthor_mariadb_nodate})
	
	\subsection{Docker}
	Docker ist eine Plattform mit der Entwickler einfach und schnell Container erstellen, bereitstellen, ausführen, aktualisieren und verwalten können.
	\autoref{fig:docker-funktionsweise} zeigt die Funktionsweise von Docker.
	Container sind eigenständige, ausführbare Einheiten die unabhängig vom OS deployed werden können.
	Container vereinfachen die Entwicklung und Bereitstellung von verteilten Anwendungen. 
	Entwickler können Container auch ohne Docker erstellen doch Docker macht die Containerisierung schneller, einfacher und sicherer. 
	Telepresence ist die neuste Erweiterung und bietet einen einfachen Weg mit Kubernetes zu entwickeln. (\textcite{ghosh_docker_2020})
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.4]{assets/docker-funktionsweise.png}
		\caption{Funktionsweise von Docker (Quelle: \textcite{bollhoff_kubernetes_2022})}
		\label{fig:docker-funktionsweise}
	\end{figure}
	
	\subsection{Microsoft .NET Core} \label{subsec:msNetCore}
	Microsoft .NET Core ist ein Open-Source und plattformübergreifendes Framework, um Applikationen auf Android, Apple, Linux und Windows Betriebssystemen zu entwickeln.
	Microsoft .NET Core unterstützt mehrere Programmiersprachen wie C\#, F\# und Visual Basic.
	Zudem bietet .NET einen Paketmanager, um einfach und effizient Bibliotheken von Drittanbietern zu verwenden.
	Die Version .NET 8 bietet einige Neuerungen wie beispielsweise Performance-focused Typen, die die Leistung einer Anwendung erheblich verbessern sollen. (\textcite{billwagner_net_nodate})

	\subsection{Microsoft ASP.NET Core}
	Microsoft ASP.NET Core ist im Gegensatz zu .NET Core ein Framework um Webanwendungen zu entwickeln. 
	ASP.NET stellt zusätzlich Frameworks zur Verfügung wie beispielsweise Blazor mit dem man einfach und effizient eine Interaktive Web-\ac{UI} mit C\# entwickeln kann.
	ASP.NET unterstützt die Entwicklung und Implementierung von \acfi{API} und Microservices.
	Zudem ist ASP.NET laut \textcite{noauthor_techempower_nodate} schneller als jedes andere beliebte Web-Framework. (\textcite{billwagner_net_nodate})
	
	\subsection{Entity Framework Core}
	\acfi{EF} Core ist eine \acfi{ORM} Technik für Microsofts .NET Core Technologie. 
	Die Technologie ist Open-Source, erweiterbar und plattformübergreifend.
	\ac{EF} Core unterstützt LINQ-Abfragen, Änderungsverfolgung sowie Schemamigration.
	Des Weiteren unterstützt \ac{EF} Core mehrere Datenbanken wie beispielsweise MySQL, PostgreSQL, Azure CosmosDB etc. und auch MariaDB.
	Die aktuelle Version von \ac{EF} Core ist 7.0 und verfügt über neue Funktionen wie zum Beispiel das Mapping und Abfragen auf \acfi{JSON} Spalten. 
	Dabei ist es möglich einzelne Parameter von einem \ac{JSON} Objekt abzufragen und zu ändern. 
	\autoref{lst:exampleOfJsonColumn} zeigt wie das erfolgt. (\textcite{billwagner_net_nodate})
	
	\begin{listing}[ht]
		\begin{minted}{csharp}
			var jeremy = await context
			.Authors
			.SingleAsync(author => author.Name.StartsWith("Jeremy"));
			
			jeremy.Contact = new() { 
				Address = new("2 Riverside", "Trimbridge", "TB1 5ZS", "UK"), 
				Phone = "01632 88346" 
			};
		
			await context.SaveChangesAsync();
		\end{minted}
		\caption{Update von einem Parameter einer \ac{JSON} Spalte}
		\label{lst:exampleOfJsonColumn}
	\end{listing}
	
	\subsection{OpenAPI}
	Die OpenAPI-Initiative hat die \acfi{OAS} entwickelt, die eine \ac{API} Beschreibung standardisiert.
	Die \ac{OAS} ist eine Sprache für \acfi{HTTP} \ac{API}s und bietet eine standardisierte Beschreibung für diese.
	Mithilfe von einem OpenAPI-Code-Generator (\textcite{noauthor_openapi_nodate-1}) kann direkt Client-Code für verschiedene Technologien wie zum Beispiel Typescript generiert werden. (\textcite{noauthor_openapi_nodate})
	
	
	
	\chapter{Anforderungen} \label{chapter:requiremnts}
	Das Hauptziel dieser Arbeit ist die Entwicklung eines \ac{TCMS} für \ac{GI}.
	Dabei steht Zuverlässigkeit, Geschwindigkeit und Skalierbarkeit im Vordergrund.
	Zudem soll darauf geachtet werden, dass Ressourcen beziehungsweise Entitäten, wie beispielsweise Testfälle, für mehrere Testpläne verwendet werden können, um damit mehrfache Einträge in der Datenbank zu verhindern.
	
	Das zu entwickelnde \ac{TCMS} hat folgende Anforderungen (Requirements):
	
	\begin{itemize}
		\setlength\itemsep{-0.5em}
		\item RE 1 - Produkt und Testsysteme beschreiben und darstellen
		\item RE 2 - Features beschreiben und darstellen
		\item RE 3 - Features zu einem Produkt zuordnen
		\item RE 4 - Testfälle beschreiben und darstellen
		\item RE 5 - Testfälle zu einem Feature zuordnen
		\item RE 6 - Testimplementierungen beschreiben und darstellen
		\item RE 7 - Testimplementierungen zu Testfällen und Testsysteme zuordnen
		\item RE 8 - Testläufe von Testimplementierungen zu einem Testsystem zuordnen
		\item RE 9 - Resultate von bestimmten Testläufen abzufragen
	\end{itemize}
	
	
	\section{Minimum Viable Product}
	Bei einem \acfi{MVP} handelt es sich um die erste funktionierende Iteration eines Produkts das nur Kernfunktionalitäten beinhaltet.
	In unserem Fall ist das ein funktionierendes \ac{TCMS}, welches die oben angeführten Anforderungen abdeckt und von der Datenbankabfrage bis zur \ac{API} unterstützt.
	Der Vorteil ist dabei der schnelle Austausch von Feedback. (\textcite{alliance_what_2017})
	
	
	\section{Testen der Funktionalitäten}
	Damit die auftraggebende Person die Funktionalitäten des \ac{TCMS} auch \acfi{UI} unterstützt testen kann, wird ein webbasiertes \ac{UI} von \emph{Swagger} zur Verfügung gestellt, siehe \autoref{fig:swaggeruiExample}.
	
	Swagger ist ein Werkzeug mit dem \ac{API}-Beschreibungen erstellt werden können.
	Zudem kann Swagger mithilfe des standardisiertem \ac{OAS} automatisch ein \ac{UI} generieren. (\textcite{noauthor_api_nodate})
	\newline
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.6]{assets/swaggerui.png}
		\caption{Beispiel \ac{UI} von Swagger (Quelle: \textcite{noauthor_host_nodate})}
		\label{fig:swaggeruiExample}
	\end{figure}

	\section{Vorgehensweise} \label{sec:userStoriesDefinition}
	Die ermittelten Anforderungen wurden in User-Stories aufgeteilt. 
	Nachfolgend sind vier User-Stories aufgeführt, die aufzeigen, welche Funktionalitäten das \ac{TCMS} beinhaltet, um die oben gelisteten Anforderungen abzudecken.
	
	\subsection{Projekt und Datenbank Aufsetzen}
	Diese User-Story beinhaltet noch keine Implementierung von Funktionalitäten, sondern beschäftigt sich mit dem Aufsetzten des Projektes und der Datenbank.
	
	Die Akzeptanzkriterien sind wie folgend:
	\begin{itemize}
		\item Projektstruktur in die Architekturschichten aufteilen 
		\item Datenbank mit Docker aufsetzen
		\item \acfi{SQL} Statements möglich
	\end{itemize}

	Diese User-Story erfüllt nicht direkt eine oben angeführte Anforderung, bietet aber die Basis für die weiteren User-Stories.
	
	\subsection{Erstellen und Suchen von Test-Environments}
	Als benutzende Person möchte ich Test-Environments erstellen und suchen können, sodass ich Testpläne zuordnen kann.
	
	Die Akzeptanzkriterien sind wie folgend:
	\begin{itemize}
		\item Erstellen von Test-Environments über das Swagger-UI
		\item Suchen von Test-Environments über das Swagger-UI
		\item Zuordnungsmöglichkeit von Testplänen über das Swagger-UI
	\end{itemize}

	Diese User-Story erfüllt die Anforderungen RE 1 und RE 3.

	\subsection{Erstellen und Suchen von Testplänen, Testfällen und Testimplementationen}
	Als benutzende Person möchte ich Testpläne, Testfälle und Testimplementationen erstellen und suchen können, sodass ich diese entsprechend zuordnen kann.
	
	Die Akzeptanzkriterien sind:
	\begin{itemize}
		\item Erstellen von Testplänen, Testfällen und Testimplementationen über das Swagger-UI
		\item Suchen von Testplänen, Testfällen und Testimplementationen über das Swagger-UI
		\item Zuordnungsmöglichkeit von Testfällen und Testimplementationen über das Swagger-UI
	\end{itemize}

	Diese User-Story erfüllt die Anforderungen RE 2, 4, 5, 6 und RE 7.
	
	\subsection{Erstellen und Suchen von Testläufe}
	Als benutzende Person möchte ich Testläufe erstellen und suchen können, sodass ich Reports generieren kann.
	
	Die Akzeptanzkriterien sind wie folgend:
	\begin{itemize}
		\item Erstellen von Testläufen über das Swagger-UI
		\item Suchen von Testläufen über das Swagger-UI
		\item Zuordnungsmöglichkeit von Testläufen über das Swagger-UI
	\end{itemize}
	
	Diese User-Story erfüllt die Anforderungen RE 8 und RE 9.
	
	\chapter{Konzept}
	Im vorherigen Kapitel wurden die Anforderungen des zu entwickelnden \ac{TCMS} festgelegt.
	Dieses Kapitel gibt einen Überblick über die konzipierte Architektur und gibt Einblick in die Planung des \ac{TCMS}.
	
	\section{Architektur}
	Grundlegend repräsentiert eine Softwarearchitektur die Organisation und den Aufbau eines Systems, was die Architektur zu einer der wichtigsten Bestandteile in der Softwareentwicklung macht.
	Die Wahl der Architektur eines Softwareprojektes hat demnach hohen Einfluss auf den späteren Verlauf des Projektes was auch bei einer Umstellung der Architektur sehr kostenintensive Auswirkungen haben kann. 
	Eine gut strukturierte Softwarearchitektur hat dementsprechend einige Vorteile (\textcite{richards_fundamentals_2020}):
	
	\begin{itemize}
		%\setlength\itemsep{-0.5em}
		\item Übersichtlichkeit
		\item bessere Wartbarkeit
		\item Erweiterbarkeit
		\item Anpassungsfähigkeit
		\item Skalierbarkeit
		\item reduziert Kosten und verhindert Code-Duplikation
		\item erhöht die Qualität der Software
		\item hilft bei komplexen Problemstellungen
		\item reduziert den Time-to-Market Faktor durch effizienteres Entwickeln
	\end{itemize}
	
	\subsection{Backend} \label{subsec:backend}
	In dieser Arbeit haben wir uns zusammen mit \ac{GI} für eine Schichtenarchitektur mit \acfi{DDD} entschieden.
	Der Aufbau dieser Architektur unterteilt sich in vier Schichten, siehe \autoref{fig:layeredArchitecture}:
	
	\begin{itemize}
		%\setlength\itemsep{-0.5em}
		\item Präsentationsschicht
		
		Diese repräsentiert \ac{API}s, die Anfragen entgegennimmt und dementsprechend Antworten liefert.
		Die Anfragen werden an die Applikationsschicht weitergeleitet.
		
		\item Applikationsschicht
		
		Diese Schicht interagiert mit der Präsentationsschicht und der Infrakstrukturschicht.
		Abhängig von den aus der Präsentationsschicht weitergeleiteten Anfragen werden Domain-Objects erzeugt und an die Infrakstrukturschicht weitergeleitet.
		
		\item Domainschicht
		
		Beinhaltet die Entitäten von der Domain und ist das Zentrum der Architektur.
		Diese Schicht wird von der Applikationsschicht und von der Infrastrukturschicht aufgerufen und beinhaltet die Business-Logik.
		
		\item Infrastrukturschicht
		
		Hier wird mit der Applikationsschicht, der Domainschicht und der Datenbank interagiert.
	\end{itemize}

	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.5]{assets/layeredArchitecture.png}
		\caption{Übersicht einer Schichtenarchitektur (Quelle: \textcite{zhang_domain_nodate})}
		\label{fig:layeredArchitecture}
	\end{figure}
	
	\ac{DDD} ist ein Designansatz, bei dem die Entitäten des Systems, abhängig von dem Input der Domainexperten, modelliert werden.
	Das erleichtert es den Teammitgliedern die Arbeit der anderen besser zu verstehen.
	Diese Verwendung trägt auch zur \emph{ubiquitous language} bei, die alle Teammitglieder bei Modell- und Entwurfsdiskussionen verwenden können. (\textcite{vernon_implementing_2013})
	
	\autoref{fig:patternsDDD} zeigt alle Komponenten, die bei \ac{DDD} zum Einsatz kommen. 
	In dieser Arbeit fokussieren wir uns speziell auf die folgenden Komponenten:
	
	\begin{itemize}
		\setlength\itemsep{-0.5em}
		\item Entities 
		\item Value-Objects
		\item Aggregates
		\item Repositories
		\item Services
	\end{itemize}
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.32]{assets/componentsDDD.jpg}
		\caption{Komponenten von \ac{DDD} (Quelle: \textcite{xu_ep32_2023})}
		\label{fig:patternsDDD}
	\end{figure}

	
	\section{Planung}
	In diesem Abschnitt geht es um die Modellierung des Domain-Models des \ac{TCMS}.
	Vor der Modellierung wurde eine Übersicht über das schon bestehenden \acfi{TAS} verschafft, dargestellt in \autoref{fig:testAutomationSystem}.
	Durch diese Übersicht wurden die Interaktionen mit dem zu entwickelnden \ac{TCMS} ermittelt.
	Dabei greift das \ac{TAS} über die Technologie \emph{Automise} über eine von \ac{TCMS} bereitgestellte \ac{API} darauf zu und erstellt Testläufe.
	In \autoref{subsec:domainModel} erfolgt eine detaillierte Beschreibung wie das \ac{TAS} Testläufe erstellt.
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.34]{assets/TestTechnologiesOverview.drawio.png}
		\caption{\ac{TAS} von \ac{GI}}
		\label{fig:testAutomationSystem}
	\end{figure}
	
	\subsection{Domain-Model} \label{subsec:domainModel}
	Zunächst wurde das Domain-Model entwickelt, um die Entitäten und deren Beziehungen darzustellen.
	Dabei wurde exakt darauf geachtet, dass die in \autoref{chapter:requiremnts} ermittelten Anforderungen vollständig abgedeckt werden.

	Die in \autoref{fig:domainModelPart1} abgebildeten Entitäten betreffen folgende Anforderungen:
	
	\begin{itemize}
		%\setlength\itemsep{-0.5em}
		\item RE 1 - Produkt und Testsysteme beschreiben
		
		Das Produkt wurde als \emph{Environment/Platform} (Test-Environment) modelliert.
		Ein Beispiel hierfür wäre ein Gerät der Firma.
		Das \emph{Testsystem} ist ein Aufbau mit Geräten (Messsystemen), die geprüft werden. 
		Beispielsweise ist das eine Prüfwand mit mehreren Geräten mit denen Tests durchgeführt werden.
		Jedes Produkt hat eigene Testsysteme.
		
		\item RE 2 - Features beschreiben und darstellen
		
		Feature wurde als \emph{Testplan/Feature} modelliert.
		Ein Testplan besteht aus mehreren Testfällen (Entität Testcase) und bildet ein Feature von einem Gerät ab.
		Ein Beispiel für ein Feature ist die Netzwerk-Connectivity von einem Gerät.
		
		\item RE 3 - Features zu einem Produkt zuordnen
		
		Die erstellten Testpläne können zu Produkten zugeordnet werden.
		Somit können Testpläne für andere Produkte wiederverwendet werden.
		
		\item RE 4 - Testfälle beschreiben und darstellen
		
		Testfall wurde als \emph{Testcase} modelliert.
	    Ein Testfall besteht aus mehreren Testimplementierungen (Entität Testimplementation).
	    Diese Testimplementierungen sind für jeden Testfall einzigartig und können nicht wiederverwendet werden. 
	    Ein Testfall ist beispielsweise eine Überprüfung, ob ein Gerät eine \acfi{DHCP} Adresse erhalten hat.
		
		\item RE 5 - Testfälle zu einem Feature zuordnen
		
		Die Testfälle können zu Features zugeordnet werden.
		Somit können Testfälle für andere Features wiederverwendet werden.
		
		\item RE 6 - Testimplementierungen beschreiben und darstellen
		
		Eine Testimplementierung wurde als \emph{Testimplementation} modelliert.
		Testimplementierungen sind Beschreibungen wie ein Testfall getestet wird und ob dieser manuell oder automatisch ausgeführt wird.
		Testimplementierungen enthalten auch Informationen, ob sie erfolgreich beim letzten Testlauf getestet worden sind.
		Eine Testimplementierungen ist die Beschreibung mit welchen Konfigurationen ein Testfall bei einem Gerät getestet wird.
		
		\item RE 7 - Testimplementierungen zu Testfällen und Testsystemen zuordnen
		
		Testimplementierungen können zu Testfällen und zu Testsystemen zugeordnet werden.
		Durch die Zuordnung von Testimplementierungen zu Testsystemen ist es möglich die Testimplementierungen von einem Produkt darzustellen.
		Somit können beispielsweise Statistiken und Reports generiert werden, die einen Überblick über jede Testimplementierungen von einem Produkt geben.
	\end{itemize}

	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.55]{assets/TCMS_DomainModel_part1.png}
		\caption{Domain-Model (Teil 1) basierend auf den Anforderungen von \autoref{chapter:requiremnts}}
		\label{fig:domainModelPart1}
	\end{figure}

	Die in \autoref{fig:domainModelPart2} abgebildeten Entitäten betreffen folgende Anforderungen:
	
	\begin{itemize}
		%\setlength\itemsep{-0.5em}
		\item RE 8 - Testläufe von Testimplementierungen zu einem Testsystem zuordnen
		
		Ein Testlauf wurde als \emph{TestRun} modelliert.
		Testläufe werden automatisch von dem bereits bestehenden \ac{TAS} der Firma erstellt und beschrieben.
		Diese Testläufe enthalten Informationen, welche Testimplementationen mit welchen Konfigurationen und mit welcher Hardware getestet wurde.
		Testläufe werden zum Zeitpunkt des Erstellens zu den jeweiligen Testsystemen, mit denen diese durchgeführt worden sind, zugeordnet.
		
		\item RE 9 - Resultate von bestimmten Testläufen abzufragen
		
		Durch die Zuordnung von Testläufen zu Testsystemen können Resultate zu jedem Testsystem abgefragt werden.
	\end{itemize}

	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.55]{assets/TCMS_DomainModel_part2.png}
		\caption{Domain-Model (Teil 2) basierend auf den Anforderungen von \autoref{chapter:requiremnts}}
		\label{fig:domainModelPart2}
	\end{figure}
	
	Die in \autoref{fig:domainModelPart1} und \autoref{fig:domainModelPart2} gezeigten Entitäten wurden auf Basis der Kommunikation mit Domainexperten modelliert.
	
	
	
	\chapter{Technische Umsetzung}
	Dieses Kapitel beschreibt die Implementierung der definierten User-Stories mit den gewählten Technologien und wie diese mit der entworfenen Architektur umgesetzt wurden. 
	Zuerst wird der allgemeine Ablauf des verwendeten Scrum-Prozesses beschrieben und im Anschluss detailliert auf die User-Stories eingegangen. 

	\section{Scrum}
	Scrum ist eine Projektmanagement-Methode zur Unterstützung der agilen Softwareentwicklung.
	Bei dieser Methode geht es darum, dass ein Team Teilaufgaben von einer komplexen Aufgabenstellung in kleinen Schritten, sogenannte \emph{Sprints}, angeht. (\textcite{rubin_essential_2012})
	
	Für die Implementierung der User-Stories wurde der in \autoref{fig:scrum-process} gezeigte Prozess angewendet.
		
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.35]{assets/scrum-process.png}
		\caption{Scrum Prozess (Quelle: \textcite{noauthor_home_nodate})}
		\label{fig:scrum-process}
	\end{figure}
	
	
	\section{Implementierung der User-Stories}
	Dieser Abschnitt zeigt den Ablauf der Implementierung der User-Stories.
	Die Implementierung ist auf vier User-Stories aufgeteilt, die in der folgenden Reihenfolge implementiert wurden:
	
	\begin{itemize}
		\item Projekt und Datenbank Aufsetzen
		\item Erstellen und Suchen von Test-Environments
		
		Um die Durchgängigkeit der Architektur zu veranschaulichen, wird bei dieser User-Story detailliert auf jede Schicht eingegangen.
		Eine detaillierte Beschreibung erfolgt in \autoref{subsec:createAndSearchTestEnvironments}.
		Dabei wurden die User-Stories in folgender Reihenfolge in die Schichten implementiert:
		
		\begin{itemize}
			\setlength\itemsep{-0.5em}
			\item Domainschicht
			\item Infrastrukturschicht
			\item Applikationsschicht
			\item Präsentationsschicht
		\end{itemize}
	
		\item Erstellen und Suchen von Testplänen, Testfällen und Testimplementationen
		
		In dieser User-Story gehen wir detailliert auf die Tabellen Konfigurationen mit \ac{EF} Core ein.
		Eine detaillierte Beschreibung erfolgt in \autoref{subsec:createAndSearchTestplans}.
		
		\item Erstellen und Suchen von Testläufe
		
		In dieser User-Story wird gezeigt, wie das \ac{TAS} von \ac{GI} mit dem \ac{TCMS} interagiert, siehe \autoref{subsec:createAndSearchTestruns}.
	\end{itemize}

	Für die Umsetzung des \ac{TCMS} kommt die Version .NET 7.0 zum Einsatz.
	Als \acfi{IDE} wurde \emph{Rider} von \emph{JetBrains} verwendet.


	\subsection{Projekt und Datenbank Aufsetzen}
	Damit eine Grundlage für die folgenden User-Stories vorhanden ist, wurde die Struktur des Projektes in vier Teilprojekte aufgeteilt.
	Dabei repräsentiert jedes Teilprojekt eine Schicht der verwendeten Architektur.
	
	Für das Aufsetzen der Datenbank wurde das von Docker bereitgestellte Tool \emph{Docker Desktop} verwendet.
	Docker Desktop ist eine Anwendung die das Erstellen und Verwalten von Container vereinfacht. (\textcite{noauthor_docker_2022})
	
	\autoref{lst:dockerDesktop} zeigt das Erstellen und Ausführen eines MariaDB Containers.
	Nachdem der Container hochgefahren ist, kann mit dem MariaDB Server gearbeitet werden.
	
	\begin{listing}[ht]
		\begin{minted}{Basic}
			docker run --name mariadb-container 
			-e MYSQL_ROOT_PASSWORD=admin -p 3306:3306 -d mariadb:latest
		\end{minted}
		\caption{Starten eines MariaDB Containers}
		\label{lst:dockerDesktop}
	\end{listing}

	\autoref{lst:createAndUseDBSchema} zeigt das Erstellen eines Datenbankschemas namens \emph{tcms\_mariadb}. 
	In dieser werden die Tabellen vom \ac{TCMS} erzeugt und verwaltet.
	
	\begin{listing}[ht]
		\begin{minted}{SQL}
			CREATE DATABASE tcms_mariadb; 
			USE tcms_mariadb;
		\end{minted}
		\caption{Erstellen und verwenden eines Datenbankschemas}
		\label{lst:createAndUseDBSchema}
	\end{listing}

	Um eine Verbindung zur Datenbank herzustellen, liegt im Projekt ein \ac{JSON}-File, das die benötigten Konfigurationen bereitstellt, siehe \autoref{lst:connectionConfigs}.
	Diese werden beim Start des Projektes in der \emph{Startup}-Klasse gelesen und verwendet, siehe \autoref{lst:registerDatabase}.
	Des Weiteren zeigt \autoref{lst:registerDatabase}, dass die Funktion \emph{AddDbContext} den Typ \emph{EFContext} bekommt. 
	Diese Klasse kümmert sich um die Konfiguration aller verwendeten Tabellen, die verwendet werden, siehe \autoref{lst:efcontextClass}.

	\autoref{lst:startupClassPart1}, \ref{lst:startupClassPart2} und \ref{lst:programClass} im Anhang zeigen die \emph{Startup} und \emph{Program}-Klasse, die für die Initiierung der Datenbank und Tabellen, der \ac{DI} Container und Generierung der Swagger-UI zuständig sind.

	\begin{listing}[ht]
		\begin{minted}{JSON}
			{
				[...]		
				"ConnectionStrings": {
					"MariaDbConnectionString": 
					"server=localhost;port=3306;database=tcms_mariadb;user=root;password=admin;"
				}
			}
		\end{minted}
		\caption{Ausschnitt der Konfigurationen für die Verbindung zur MariaDB Datenbank}
		\label{lst:connectionConfigs}
	\end{listing}

	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]		
			services.AddDbContext<EFContext>(dbContextOptions => {
				var connectionString = _config
					.GetConnectionString("MariaDbConnectionString");
				
				dbContextOptions
					.UseMySql(connectionString,
						ServerVersion.AutoDetect(connectionString));
			});		
			[...]
		\end{minted}
		\caption{Ausschnitt der \emph{Startup}-Klasse, der das Registrieren der Datenbank zeigt}
		\label{lst:registerDatabase}
	\end{listing}

	\subsection{Erstellen und Suchen von Test-Environments} \label{subsec:createAndSearchTestEnvironments}
	Zuerst erfolgte die Implementierung der Domain-Models, \emph{Test-Environment} und \emph{Testsystem}, in der Domainschicht.
	Im Anschluss wurden die Interfaces für die Infrastrukturschicht definiert, die ebenfalls in der Domainschicht liegen.
	Somit kann die Infrastrukturschicht einfach und ohne Abhängigkeiten ausgetauscht werden.
	
	Als nächster Schritt wurde das definierte Interface (Siehe: \autoref{lst:testEnvironmentRepository}) in der Infrastrukturschicht implementiert.

	\begin{listing}[ht]
		\begin{minted}{csharp}
			public interface ITestEnvironmentRepository
			{
				string NextIdentity();
				Task<TestEnvironment> FindById(string id);
				Task<List<TestEnvironment>> FindByShortDescription(string shortDescription);
				Task<List<TestEnvironment>> GetAll();
				[...]
			}
		\end{minted}
		\caption{Test-Environment Aggregate Interface, für die Infrastrukturschicht}
		\label{lst:testEnvironmentRepository}
	\end{listing}

	Mithilfe der \ac{ORM} Technologie \ac{EF} Core können Objekte ohne \ac{SQL} Statements in die Datenbank geschrieben, gelesen, gelöscht und aktualisiert werden.
	\autoref{lst:testEnvironmentRepositoryAusschnitt_1} zeigt wie ein Test-Environment mit einem \acfi{ID} von der Datenbank ausgelesen werden kann.
	
	Damit wir das von \autoref{lst:testEnvironmentRepositoryAusschnitt_1} ausgelesene Test-Environment-Objekt weiter verwenden können, wurde ein \emph{TestEnvironmentService} in der Applikationsschicht implementiert. 
	Dabei wird für den Service sowohl ein Interface definiert als auch eine implementierende Klasse \emph{TestEnvironmentService} realisiert.
	
	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]		
			public async Task<TestEnvironment> FindById(string id)
			{
				return await _context.TestEnvironments
					.Include(te => te.TestSystems)
					.Include(tp => tp.TestEnvironmentPlans)
					.FirstOrDefaultAsync(testEnvironment => testEnvironment.DomainId == id);		
			}		
			[...]
		\end{minted}
		\caption{Ausschnitt der \emph{TestEnvironmentRepository}-Klasse, die ein Test-Environment-Objekt mithilfe einer \ac{ID} von der Datenbank ausliest}
		\label{lst:testEnvironmentRepositoryAusschnitt_1}
	\end{listing}
	
	Der in \autoref{lst:testEnvironmentServiceAusschnitt} gezeigte Code bekommt das Test-Environment-Objekt von der Infrastrukturschicht zurück und wandelt es in ein \acfi{DTO} um.
	Das \ac{DTO} wird anschließend von der Applikationsschicht in die Präsentationsschicht weitergeleitet.

	\begin{listing}[!htb]
		\begin{minted}{csharp}
			[...]				
			public async Task<TestEnvironmentDTO> FindById(string id)
			{
				var testEnvironment = await _testEnvironmentRepository.FindById(id);	
				return new TestEnvironmentDTO
				{
					Id = testEnvironment.DomainId,
					ShortDescription = testEnvironment.ShortDescription,
					LongDescription = testEnvironment.LongDescription,
					[...]	
				};
			}			
			[...]
		\end{minted}
		\caption{Ausschnitt der \emph{TestEnvironmentService}-Klasse}
		\label{lst:testEnvironmentServiceAusschnitt}
	\end{listing}

	Der in \autoref{lst:testEnvironmentControllerAusschnitt_1} gezeigte Code bekommt das umgewandelte Test-Environment-Objekt (\ac{DTO}) von der Applikationsschicht zurück und schickt es dem Client weiter.
	
	\begin{listing}[!htb]
		\begin{minted}{csharp}
			[...]	
			[HttpGet("{id}")]
			public async Task<ActionResult<TestEnvironmentDTO>> 
			FindTestEnvironmentById(string id)
			{
				var testEnvironmentDTO = await _testEnvironmentService.FindById(id);
				return Ok(testEnvironmentDTO);
			}	
			[...]
		\end{minted}
		\caption{Ausschnitt der \emph{TestEnvironmentController}-Klasse}
		\label{lst:testEnvironmentControllerAusschnitt_1}
	\end{listing}

	Der oben gezeigte Ablauf beschreibt die Suche nach einem Test-Environment. 
	Beim Erstellen passiert ähnliches, nur dass der Client ein \ac{DTO} über den bereitgestellten Endpunkt der \ac{API} schickt.
	Die \emph{TestEnvironmentController}-Klasse empfängt das \ac{DTO} und schickt es der Applikationschicht weiter, diese Schicht wandelt es von einem \ac{DTO} in ein Domain-Objekt um und schickt es weiter zur Infrastukturschicht, die es dann persistiert.
	
	Der in \autoref{lst:testEnvironmentRepositoryAusschnitt_2} gezeigte Code zeigt das Schreiben eines Test-Environment-Objekts in die Datenbank.
	
	\begin{listing}[!htb]
		\begin{minted}{csharp}
			[...]	
			public async Task Add(TestEnvironment testEnvironment)
			{
				await _context.TestEnvironments.AddAsync(testEnvironment);
				await _context.SaveChangesAsync();
			}
			[...]
		\end{minted}
		\caption{Ausschnitt der \emph{TestEnvironmentRepository}-Klasse}
		\label{lst:testEnvironmentRepositoryAusschnitt_2}
	\end{listing}
	
	\subsubsection{Swagger-UI}
	%Abschließend werden die \emph{TestEnvironmentService} und \emph{TestEnvironmentRepository}-Klassen in der \emph{EFContext}-Klasse (Siehe: \autoref{lst:startupClassPart1}) für den \acfi{DI} Container registriert.
	Die Verwendung von \emph{Swagger} sieht vor, dass beim Start des Projektes die \emph{TestEnvironmentController}-Klasse gescannt und dadurch eine Weboberfläche generiert wird (Siehe: \autoref{fig:swaggeruiTestenvironment}).
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.5]{assets/swaggerui_testenvironment.png}
		\caption{Test-Environment \ac{UI} von Swagger}
		\label{fig:swaggeruiTestenvironment}
	\end{figure}
	
	\subsection{Erstellen und Suchen von Testplänen, Testfällen und Testimplementationen} \label{subsec:createAndSearchTestplans}
	Der Ablauf der Implementierung für die User-Story \emph{Erstellen und Suchen von Testplänen, Testfällen und Testimplementationen} erfolgte analog zu dem oben beschriebenen Verfahren.
	
	Zuerst wurden die Domain-Models erstellt, dann das Repository, gefolgt von dem Service und dem Controller.
	Zudem werden beim Start des Projektes die \emph{Controller}-Klassen gescannt und eine Weboberfläche generiert.
	Somit ist das Erstellen und Suchen von Testplänen, Testfällen und Testimplementationen auf dem Swagger-UI verfügbar. 
	
	\subsubsection{Tabellen Konfiguration mit EF Core}
	Damit beispielsweise die Testpläne einem Test-Environment zugewiesen werden können, muss eine \emph{Junction} Tabelle erstellt werden, da zwischen Testplan und Test-Environment eine Many-to-many Beziehung herrscht.
	
	Dadurch, dass eine \emph{Junction} Tabelle benötigt wird, wurde die \emph{TestEnvironmentPlan}-Klasse erstellt, die lediglich die Domain-\ac{ID}s beider Domain-Klassen, \emph{TestEnvironment} und \emph{TestPlan}, beinhaltet (Siehe: \autoref{lst:testEnvironmentPlanClass}). 
	Damit die zwei Domain-Klassen später in den \ac{EF} Core Tabellenkonfigurationen als Many-to-many Beziehung konfigurierbar sind, ist die \emph{TestEnvironmentPlan}-Klasse als \emph{Property} in beiden Klassen vorhanden.
	
	\begin{listing}[ht]
		\begin{minted}{csharp}
			public class TestEnvironmentPlan
			{
				public string TestEnvironmentDomainId {get; private set;}
				public string TestPlanDomainId {get; private set;}
				
				public TestEnvironmentPlan(
					string testEnvironmentDomainId, 
					string testPlanDomainId
				) {
					TestEnvironmentDomainId = testEnvironmentDomainId;
					TestPlanDomainId = testPlanDomainId;
				}
			}
		\end{minted}
		\caption{\emph{TestEnvironmentPlan}-Klasse}
		\label{lst:testEnvironmentPlanClass}
	\end{listing}
	
	Der in \autoref{lst:testEnvironmentAndPlanConfigurationClass} gezeigte Code konfiguriert einen Teil der Tabellen \emph{TestEnvironment} und \emph{TestPlan}.
	Dadurch wird festgelegt, dass die Tabellen \emph{TestEnvironment} und \emph{TestPlan} eine Many-to-one Beziehung zu der \emph{Junction} Tabelle haben.
	
	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]	
			builder // TestEnvironment - many to one - TestEnvironmentPlan
				.HasMany(e => e.TestEnvironmentPlans)
				.WithOne()
				.HasPrincipalKey(e => e.DomainId)
				.IsRequired();
			[...]	
			builder // TestPlan - many to one - TestEnvironmentPlan
				.HasMany(e => e.TestEnvironmentPlans)
				.WithOne()
				.HasPrincipalKey(e => e.DomainId)
				.IsRequired();							
			[...]
		\end{minted}
		\caption{Ausschnitt aus der \emph{TestEnvironmentConfiguration} und \emph{TestPlanConfiguration}-Klasse}
		\label{lst:testEnvironmentAndPlanConfigurationClass}
	\end{listing}

	Der in \autoref{lst:testEnvironmentPlanConfigurationClass} gezeigte Code konfiguriert einen Teil der \emph{Junction} Tabelle \emph{TestEnvironmentPlan}.
	Dadurch wird festgelegt, dass die \emph{TestEnvironmentPlan} Tabelle eine Many-to-one Beziehung zu den Tabellen \emph{TestEnvironment} und \emph{TestPlan} hat.

	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]			
			builder.HasKey(e => new {e.TestEnvironmentDomainId, e.TestPlanDomainId});
			
			builder // TestEnvironmentPlan - many to one - TestEnvironment
				.HasOne<TestEnvironment>()
				.WithMany(e => e.TestEnvironmentPlans)
				.HasPrincipalKey(e => e.DomainId)
				.IsRequired();
				
			builder // TestEnvironmentPlan - many to one - TestPlan
				.HasOne<TestPlan>()
				.WithMany(e => e.TestEnvironmentPlans)
				.HasPrincipalKey(e => e.DomainId)
				.IsRequired();				
			[...]
		\end{minted}
		\caption{Ausschnitt aus der \emph{TestEnvironmentPlanConfiguration}-Klasse}
		\label{lst:testEnvironmentPlanConfigurationClass}
	\end{listing}
	
	Dadurch ergibt sich eine Many-to-Many Beziehung und es wird ermöglicht, dass Testpläne zu einem Test-Environment zuweisbar sind.
	
	Um ein Test-Environment und dazugehörige Testpläne abzufragen, wurde eine \emph{TestEnvironmentManager}-Klasse in der Applikationsschicht implementiert.
	Diese Klasse hat Zugriff auf die \emph{TestEnvironmentRepository}- und \emph{TestPlanRepository}-Klassen.
	\autoref{lst:testEnvironmentManagerClass} im Anhang zeigt, wie dies erfolgt.
	
	\subsection{Erstellen und Suchen von Testläufe} \label{subsec:createAndSearchTestruns}
	
	Der Ablauf der Implementierung erfolgte analog zu den vorherigen User-Stories.
	Die \ac{EF} Core Konfiguration besteht aus folgenden Beziehungen:
	
	\begin{itemize}
		\item Many-to-one zu der \emph{Testsystem} Domain-Klasse
		
		Dadurch wird ermöglicht, dass alle Testläufe eines Testsystems von einem Test-Environment abgefragt werden können.
		
		\item One-to-many zu der \emph{ResultDetails} ValueObject-Klasse
		\item One-to-many zu der \emph{DeviceDetail} ValueObject-Klasse
	\end{itemize}
	
	\autoref{lst:testRunConfigurationClass} zeigt wie ein \emph{Dictionary} mit \ac{EF} Core konfiguriert wird.
	Dabei wird das \emph{Dictionary} als \ac{JSON} in eine \ac{JSON}-Spalte geschrieben.
	Beim Auslesen wird das \ac{JSON}-Objekt wieder in ein \emph{Dictionary} deserialisiert.
	
	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]			
			builder
				.Property(p => p.ResultDetailsMap)
				.HasConversion<string>(
					d => JsonConvert.SerializeObject(d),
					s => JsonConvert.DeserializeObject<Dictionary<string, ResultDetails>>(s) ??
						new Dictionary<string, ResultDetails>()
			);				
			[...]
		\end{minted}
		\caption{Ausschnitt aus der \emph{TestRunConfiguration}-Klasse}
		\label{lst:testRunConfigurationClass}
	\end{listing}
	
	Die Testimplementationen sind, wie die Testläufe, in einer Many-to-one Beziehung zu der \emph{Testsystem}-Klasse. 
	Dadurch ist es möglich, anhand des Status der Testimplementationen, Statistiken und Reports zu erstellen, die angeben in welchem Zustand ein Feature (Testplan) eines Gerätes (Test-Environment) ist und ob es Release bereit ist.
	
	\subsubsection{Automatische Erstellung von Testläufen über das TAS}
	Über bereitgestellte \ac{API}s ermöglicht das \ac{TCMS} dem \ac{TAS} von \ac{GI} Testläufe automatisch zu erstellen.
	Ein Ablauf eines \ac{TAS} sieht wie folgt aus:
	
	\begin{itemize}
		\item Ein Testlauf wird beim Start des \ac{TAS} erstellt.
		
		Jeder Test des \ac{TAS} beinhaltet eine \ac{ID} von einer Testimplementation.
		
		\item Nach Beendigung eines Tests benachrichtigt das \ac{TAS}, über eine bereitgestellte \ac{API}, das \ac{TCMS}.
		
		Der Testlauf der beim Start erstellt wurde, wird nun aus der Datenbank ausgelesen. 
		Die Resultate, die das \ac{TAS} mit der zugehörigen Testimplementation \ac{ID} sendet, wird in das \emph{Dictionary}, welches Teil der \emph{Testlauf}-Klasse ist, hinzugefügt.
		Der Testlauf wird anschließend in der Datenbank aktualisiert.
		
		\item Nach Beendigung des gesamten Testablaufs wird das Enddatum beim Testlauf eingetragen.
	\end{itemize}
	
	Testläufe können auch manuell über die Swagger-UI erstellt werden.
	
	\chapter{Evaluierung und Ausblick}
	Dieses Kapitel reflektiert den Entwicklungsprozess sowie die technische Umsetzung des \ac{TCMS} und beschreibt mögliche Verbesserungsmöglichkeiten.
	Des Weiteren wird ein kurzer Ausblick in die Zukunft des \ac{TCMS} gegeben.
	
	\section{Verbesserungsmöglichkeiten}
	In diesem Abschnitt werden potenzielle Verbesserungsmöglichkeiten für die umgesetzte Lösung erläutert.
	Obwohl die Umsetzung die Ziele dieser Arbeit erreicht hat, ist es wichtig mögliche Optimierungen und Verbesserungen der bestehenden Lösung aufzuzeigen, da dadurch potenzielle Verbesserungsmöglichkeiten, wie beispielsweise Code-Duplikation, aufgedeckt werden können.
	Folgend werden zwei Verbesserungsmöglichkeiten beschrieben.

	\subsection{Basis-Klassen}
	Bei der Implementierung der User-Stories wurde ersichtlich, dass einige Funktionalitäten, wie zum Beispiel \autoref{lst:testEnvironmentRepository} zeigt, für mehrere Domain-Objekte \emph{TestEnvironment}, \emph{TestPlan} etc. gleich sind.
	Um das zu verhindern, könnten Basis-Klassen in der Infrastruktur- und Applikationsschicht verwendet werden.
	Beispielsweise könnten die Klassen \emph{TestEnvironmentRepository} und \emph{TestPlanRepository} Basisfunktionalitäten von einer Basis-Klasse erben.
	Somit könnte ein großer Teil der Codebase verkleinert werden.
	
	\subsection{Automapper}
	Bei der Entwicklung der \emph{Controller}-Klassen hat sich gezeigt, dass sich die Umwandlung von \ac{DTO}s in Domain-Objekte und umgekehrt mehrfach wiederholt.
	Eine Third-Party Bibliothek names \emph{AutoMapper} könnte die Umwandlungen um einiges vereinfachen. (\textcite{noauthor_automapper_nodate})
	
	\autoref{fig:autoMapperExample} zeigt wie \ac{DTO}s zu Domain-Objekten mit \emph{AutoMapper} umgewandelt werden können.
	Somit wird die Übersichtlichkeit des Codes verbessert und Code-Duplikation verhindert.
	
	\begin{figure}[ht]
		\centering
		\includegraphics[scale=0.3]{assets/AutoMapper_example.png}
		\caption{Funktionsweise von \emph{AutoMapper} (Quelle: \textcite{sanjay_implement_2020})}
		\label{fig:autoMapperExample}
	\end{figure}
	
	\section{Ausblick}
	Die technische Umsetzung des \ac{TCMS} Backends in Zusammenarbeit mit \emph{\acl{GI}} war der erste Schritt zur Realisierung eines Vollständigem \emph{\acl{TCMS}s}.
	
	Aus der Sicht des Backends werden in Zukunft die oben aufgelisteten Verbesserungsmöglichkeiten implementiert und gegebenenfalls weitere Features eingebaut.
	Des Weiteren wird ein Frontend mit den Technologien \emph{React} und \emph{TypeScript} entwickelt.
	
	Dadurch wird es möglich über eine Weboberfläche Statistiken und Reports für Systeme und Geräte erstellen zu lassen. Diese dienen als Basis für eine Analyse und um einen Überblick zu bekommen, welche Features getestet und Release-fähig sind.
	
	\chapter{Zusammenfassung}
	Ziel dieser Arbeit war es ein funktionierendes \ac{TCMS} zu implementieren. 
	Anhand der Kommunikation mit den Domainexperten wurden Anforderungen erstellt die in \autoref{chapter:requiremnts} beschrieben sind.
	Anhand dieser Anforderungen wurde dann ein entsprechendes Domain-Model erstellt, das die angegebenen Kriterien vollständig abgedeckt hat.
	Darauf aufbauend wurden User-Stories für die Umsetzung der gegebenen Anforderungen geplant.	
	
	Mittels ausgewählter Technologien erfolgte eine dementsprechende Umsetzung eines \ac{TCMS} in C\#.
	Angefangen mit der User-Story \emph{Erstellen und Suchen von Test-Environments}, wurde eine vierschichtige Architektur implementiert worden.
	Mithilfe dieser Architektur konnten, mit wenig Aufwand, die restlichen User-Stories implementiert werden.
	
	Betrachtet man die Ergebnisse der technischen Umsetzung\footnote{https://github.com/iiNomad23/FHV\_BachelorThesis} kann für die vierschichtige Architektur und den angewendeten Technologien eine Empfehlung ausgesprochen werden. 
	Entwickler:innen die Erfahrung mit den genannten Technologien und der Architektur haben, können damit einfach und effizient ein eigenes \ac{TCMS} entwickeln.
	
	Die definierten Ziele konnten erfolgreich umgesetzt und die anfangs gestellten relevanten Fragen, unterstützend mit der Umsetzung, beantwortet werden.
	
	
	% Literaturverzeichnis
	\clearpage
	\phantomsection
	\addcontentsline{toc}{chapter}{Literaturverzeichnis}
	\printbibliography
	
	% Anhang
	\chapter*{Anhang}
	\addcontentsline{toc}{chapter}{Anhang}
	\begin{listing}[ht]
		\begin{minted}{csharp}
			public class Startup
			{
				private readonly IConfiguration _config;		
				
				public Startup(IConfiguration config) { _config = config; }
				
				// This method gets called by the runtime. 
				// Use this method to add services to the container.
				public void ConfigureServices(IServiceCollection services)
				{
					// Register database with the DI container
					services.AddDbContext<EFContext>(dbContextOptions => {
						var connectionString = _config
							.GetConnectionString("MariaDbConnectionString");	
									
						dbContextOptions
							.UseMySql(connectionString,
								ServerVersion.AutoDetect(connectionString));
					});
					
					// Register repositories with the DI container
					services.AddTransient<ITestCaseRepository, TestCaseRepository>();
					services.AddTransient<ITestPlanRepository, TestPlanRepository>();
					[...]
					
					// Register services with the DI container
					services.AddTransient<ITestCaseService, TestCaseService>();
					services.AddTransient<ITestPlanService, TestPlanService>();
					[...]
					
					services.AddControllers();
					services.AddSwaggerGen(c => { 
							c.SwaggerDoc("v1", 
								new OpenApiInfo { Title = "API", Version = "v1" }); 
					});
				}
				
			[...]
		\end{minted}
		\caption{\emph{Startup}-Klasse Teil 1}
		\label{lst:startupClassPart1}
	\end{listing}

	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]
				
				// This method gets called by the runtime. 
				// Use this method to configure the HTTP request pipeline.
				public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
				{
					if (env.IsDevelopment())
					{
						app.UseDeveloperExceptionPage();
						app.UseSwagger();
						app.UseSwaggerUI(c => 
							c.SwaggerEndpoint(
								"/swagger/v1/swagger.json", 
								"API v1"
							)
						);
					}
					
					app.UseHttpsRedirection();
					app.UseRouting();
					app.UseAuthorization();
					app.UseEndpoints(endpoints => { endpoints.MapControllers(); });
				}
			}
		\end{minted}
		\caption{\emph{Startup}-Klasse Teil 2}
		\label{lst:startupClassPart2}
	\end{listing}

	\begin{listing}[ht]
		\begin{minted}{csharp}
			public class Program
			{
				public static void Main(string[] args)
				{
					// Use this line of code when we are going production
					// CreateHostBuilder(args).Build().Run();
					
					// Remove the code block below when we are going production
					var host = CreateHostBuilder(args).Build();	
					using (var scope = host.Services.CreateScope())
					{
						var services = scope.ServiceProvider;
						var dbContext = services.GetRequiredService<EFContext>();
						dbContext.Database.EnsureDeleted();
						dbContext.Database.EnsureCreated();
					}
					
					host.Run();
				}
				
				private static IHostBuilder CreateHostBuilder(string[] args)
				{
					return Host
						.CreateDefaultBuilder(args)
						.ConfigureWebHostDefaults(webBuilder => { 
							webBuilder.UseStartup<Startup>(); 
						});
				}
			}
		\end{minted}
		\caption{\emph{Program}-Klasse, die die \emph{Startup}-Klasse verwendet}
		\label{lst:programClass}
	\end{listing}

	\begin{listing}[ht]
		\begin{minted}{csharp}
			public class EFContext : DbContext
			{
				public DbSet<TestCase> TestCases { get; set; }
				public DbSet<TestPlan> TestPlans { get; set; }
				public DbSet<TestImplementation> TestImplementations { get; set; }
				public DbSet<TestRun> TestRuns { get; set; }
				public DbSet<TestEnvironment> TestEnvironments { get; set; }		
				public DbSet<TestSystem> TestSystems { get; set; }
				[...]
				
				public EFContext(DbContextOptions<EFContext> options) : base(options) { }	
				public EFContext() { }
				
				protected override void OnModelCreating(ModelBuilder modelBuilder)
				{
					base.OnModelCreating(modelBuilder);
					
					ApplyChildConfigurations(modelBuilder);
					
					modelBuilder.ApplyConfiguration(new TestCaseConfiguration());
					modelBuilder.ApplyConfiguration(new TestPlanConfiguration());
					modelBuilder.ApplyConfiguration(new TestImplementationConfiguration());
					modelBuilder.ApplyConfiguration(new TestRunConfiguration());
					modelBuilder.ApplyConfiguration(new TestEnvironmentConfiguration());
					[...]
				}
				
				private static void ApplyChildConfigurations(ModelBuilder modelBuilder)
				{
					modelBuilder.ApplyConfiguration(new TestSystemConfiguration());
					modelBuilder.ApplyConfiguration(new TestEnvironmentPlanConfiguration());
					[...]
				}
			}
		\end{minted}
		\caption{
			\emph{EFContext}-Klasse, die \ac{EF} Core verwendet, um die Tabellen zu erstellen. 
			Diese Klasse wird, bei der Registrierung der Datenbank, in \autoref{lst:startupClassPart1} als Typ angegeben.
		}
		\label{lst:efcontextClass}
	\end{listing}

	\begin{listing}[ht]
		\begin{minted}{csharp}
			[...]
			
			public async Task<TestEnvironmentWithTestPlansDTO> FindByIdWithTestPlans(string id)
			{
				var testEnvironment = await _testEnvironmentRepository.FindById(id);
				
				var testEnvironmentPlanIds = testEnvironment.TestEnvironmentPlans
					.Select(item => item.TestPlanDomainId)
					.ToArray();
				
				var testPlans = await _testPlanRepository.FindByIdSet(testEnvironmentPlanIds);
				
				var testPlanDTOs = testPlans
					.Select(tp => new TestPlanDTO
						{
							Id = tp.DomainId,
							ShortDescription = tp.ShortDescription,
							LongDescription = tp.LongDescription,
							ReferenceLink = tp.ReferenceLink
						}
					)
					.ToList();
				
				var testEnvironmentDTO = new TestEnvironmentDTO
				{
					Id = testEnvironment.DomainId,
					ShortDescription = testEnvironment.ShortDescription,
					LongDescription = testEnvironment.LongDescription,
					TestSystems = testEnvironment.TestSystems
						.Select(ts => new TestSystemDTO
							{
								Name = ts.Name,
								Description = ts.Description,
							}
						)
						.ToList()
				};
				
				var testEnvironmentWithTestPlansDTO = new TestEnvironmentWithTestPlansDTO
				{
					TestEnvironmentDTO = testEnvironmentDTO,
					TestPlanDTOs = testPlanDTOs
				};
				
				return testEnvironmentWithTestPlansDTO;
			}
		
			[...]
		\end{minted}
		\caption{Ausschnitt der \emph{TestEnvironmentManager}-Klasse die das Interface \emph{ITestEnvironmentManger} implementiert}
		\label{lst:testEnvironmentManagerClass}
	\end{listing}
		
	% Eidesstattliche Erklärung
	\clearpage
	\chapter*{Eidesstattliche Erklärung}
	\addcontentsline{toc}{chapter}{Eidesstattliche Erklärung}
	Ich erkläre hiermit an Eides statt, dass ich vorliegende Bachelorarbeit selbstständig und ohne Benutzung anderer als der angegebenen Hilfsmittel angefertigt habe. 
	Die aus fremden Quellen direkt oder indirekt übernommenen Stellen sind als solche kenntlich gemacht. 
	Die Arbeit wurde bisher weder in gleicher noch in ähnlicher Form einer anderen Prüfungsbehörde vorgelegt und auch noch nicht veröffentlicht.
	
	\vspace{5cm}
	\noindent
	Dornbirn, am \displaydate{date} \hfill Marco Prescher
	
	
\end{document}